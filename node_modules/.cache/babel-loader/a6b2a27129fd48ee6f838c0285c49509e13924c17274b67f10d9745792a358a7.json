{"ast":null,"code":"import _classPrivateFieldLooseBase from \"/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";\nimport _classPrivateFieldLooseKey from \"/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";\nvar _Card;\nvar _safe = /*#__PURE__*/_classPrivateFieldLooseKey(\"safe\");\nvar _markSafe = /*#__PURE__*/_classPrivateFieldLooseKey(\"markSafe\");\nvar _sanitizeDate = /*#__PURE__*/_classPrivateFieldLooseKey(\"sanitizeDate\");\nvar _sanitizeImg = /*#__PURE__*/_classPrivateFieldLooseKey(\"sanitizeImg\");\nexport default class Card {\n  // Each card gets the given info and a random unique identifier.\n  constructor({\n    isClue = true,\n    date,\n    info,\n    img,\n    color\n  }) {\n    Object.defineProperty(this, _markSafe, {\n      value: _markSafe2\n    });\n    this.isClue = void 0;\n    this.id = void 0;\n    this.date = void 0;\n    this.info = void 0;\n    this.img = void 0;\n    this.color = void 0;\n    Object.defineProperty(this, _safe, {\n      writable: true,\n      value: void 0\n    });\n    this.isClue = isClue;\n    this.id = crypto.randomUUID();\n    this.date = new Date();\n    this.date.setFullYear(date);\n    this.info = info;\n    this.img = img;\n    this.color = color;\n    _classPrivateFieldLooseBase(this, _safe)[_safe] = false; // Has this card been sanitized?\n  }\n  // PUBLIC METHODS\n\n  get isSafe() {\n    return _classPrivateFieldLooseBase(this, _safe)[_safe];\n  }\n\n  /** Creat a new card with sanitized input.\n   * - The date must be an integer string <= the current year (including\n   *   negative numbers).\n   * - The info is converted to plain text using textContent.\n   * - The image, if present, is downloaded and cached.\n   *\n   * The parameters are the same as for new Card().\n   *\n   * Returns: Card with validated content (with safe property set to true), or\n   * null if the input was invalid.\n   */\n  static async newSafeCard({\n    isClue,\n    date,\n    info,\n    img,\n    color\n  }) {\n    let card = null;\n    try {\n      let cleanDate = _classPrivateFieldLooseBase(Card, _sanitizeDate)[_sanitizeDate](date);\n      let cleanInfo = Card.info; // React already sanitizes (?)\n      let cleanImg = await _classPrivateFieldLooseBase(Card, _sanitizeImg)[_sanitizeImg](img).catch(console.error);\n\n      // The date is the only dealbreaker. We just skip a bad image link.\n      if (cleanDate) {\n        card = new Card({\n          isClue: isClue,\n          date: cleanDate,\n          info: cleanInfo,\n          img: cleanImg,\n          color: color\n        });\n        _classPrivateFieldLooseBase(card, _markSafe)[_markSafe]();\n        return card;\n      } else {\n        throw new Error(`Could not sanitize card input with date '${date}', info '${info}'`);\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    return card;\n  }\n\n  // PRIVATE METHODS\n  // Sanitize input \n\n  /**\n   * Return the year if positive or year BC if negative. (Deals with the year\n   * only.) \n   *\n   * Technically BC should be offset by one year but we told users to use\n   * negative numbers as years BC.\n   *\n   * Returns: Formatted string for year, with BC if the year was\n   * negative\n   */\n  dateToString() {\n    if (this.isClue) {\n      return \"Clue\";\n    } else {\n      let yearZero = new Date();\n      yearZero.setFullYear(0);\n      let displayYear = this.year;\n      if (this.date < yearZero) {\n        displayYear = `${-displayYear} bce`;\n      }\n      return displayYear;\n    }\n  }\n\n  // Return the date as YYYY year string.\n  get year() {\n    return this.date.getFullYear();\n  }\n  set year(YYYY) {\n    if (YYYY) {\n      this.date.setFullYear(YYYY);\n    }\n  }\n}\n_Card = Card;\nfunction _markSafe2() {\n  _classPrivateFieldLooseBase(this, _safe)[_safe] = true;\n  return this;\n}\nfunction _sanitizeDate2(raw) {\n  let date = null;\n  try {\n    let numTest = Number(raw);\n    if (!isNaN(numTest) && Number.isInteger(numTest) && numTest <= new Date().getFullYear()) {\n      let date = new Date();\n      date.setFullYear(numTest);\n    } else {\n      throw `Bad date input ${raw}`;\n    }\n  } catch (e) {\n    console.error(e);\n  }\n  return date;\n}\nasync function _sanitizeImg2(url) {\n  function getImageIfExists(url) {\n    return new Promise((resolve, reject) => {\n      const img = new Image();\n      img.src = url;\n      img.onload = () => resolve(true);\n      img.onerror = () => resolve(false);\n    });\n  }\n  let testedUrl = null;\n  if (url) {\n    let imgTest = await getImageIfExists(url).catch(console.log);\n    if (imgTest === true) {\n      testedUrl = url;\n    } else {\n      throw `Image not found at url '${url}'`;\n    }\n  }\n  return testedUrl;\n}\nObject.defineProperty(Card, _sanitizeImg, {\n  value: _sanitizeImg2\n});\nObject.defineProperty(Card, _sanitizeDate, {\n  value: _sanitizeDate2\n});","map":{"version":3,"names":["Card","constructor","isClue","date","info","img","color","Object","defineProperty","_markSafe","value","_markSafe2","id","_safe","writable","crypto","randomUUID","Date","setFullYear","_classPrivateFieldLooseBase","isSafe","newSafeCard","card","cleanDate","_sanitizeDate","cleanInfo","cleanImg","_sanitizeImg","catch","console","error","Error","e","dateToString","yearZero","displayYear","year","getFullYear","YYYY","_Card","_sanitizeDate2","raw","numTest","Number","isNaN","isInteger","_sanitizeImg2","url","getImageIfExists","Promise","resolve","reject","Image","src","onload","onerror","testedUrl","imgTest","log"],"sources":["/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/src/classes/Card.tsx"],"sourcesContent":["interface CardInput  {\n  isClue: boolean;  // Is this a clue (true) or answer?\n  date: number;     // Four-digit year of event\n  info: string;     // Brief description of event\n  img: string;      // Full URL of image\n  color: string     // CSS color to be used in timeline\n}\n\nexport default class Card {\n  isClue: boolean;\n  id: string;\n  date: Date;\n  info: string;\n  img: string;\n  color: string;\n  #safe: boolean;\n\n  // Each card gets the given info and a random unique identifier.\n  constructor({ isClue = true, date, info, img, color }: CardInput) {\n    this.isClue = isClue;\n    this.id = crypto.randomUUID();\n    this.date = new Date();\n    this.date.setFullYear(date);\n    this.info = info;\n    this.img = img;\n    this.color = color;\n    this.#safe = false; // Has this card been sanitized?\n  }\n\n  #markSafe(): Card {\n    this.#safe = true;\n    return this;\n  }\n\n  // PUBLIC METHODS\n\n  get isSafe(): boolean {\n    return this.#safe;\n  }\n\n  /** Creat a new card with sanitized input.\n   * - The date must be an integer string <= the current year (including\n   *   negative numbers).\n   * - The info is converted to plain text using textContent.\n   * - The image, if present, is downloaded and cached.\n   *\n   * The parameters are the same as for new Card().\n   *\n   * Returns: Card with validated content (with safe property set to true), or\n   * null if the input was invalid.\n   */\n  static async newSafeCard({ isClue, date, info, img, color }: \n                           CardInput): Card | null {\n    let card = null;\n    try {\n      let cleanDate = Card.#sanitizeDate(date);\n      let cleanInfo = Card.info; // React already sanitizes (?)\n      let cleanImg = await Card.#sanitizeImg(img).catch(console.error);\n\n      // The date is the only dealbreaker. We just skip a bad image link.\n      if (cleanDate) {\n        card = new Card({\n          isClue: isClue, \n          date: cleanDate, \n          info: cleanInfo, \n          img: cleanImg, \n          color: color});\n          card.#markSafe();\n          return card;\n      } else {\n        throw new Error(`Could not sanitize card input with date '${date}', info '${info}'`);\n      }\n    } catch(e) {\n      console.error(e);\n    }\n    return card;\n  }\n\n  // PRIVATE METHODS\n  // Sanitize input \n  static #sanitizeDate(raw: any): Date | null {\n    let date = null;\n    try {\n      let numTest = Number(raw);\n      if (!isNaN(numTest) \n          && Number.isInteger(numTest) \n          && numTest <= new Date().getFullYear()) {\n\n          let date = new Date();\n          date.setFullYear(numTest);\n        } else {\n          throw `Bad date input ${raw}`;\n        }\n    } catch(e) { \n      console.error(e);\n    }\n    return date;\n  }\n\n  static async #sanitizeImg(url: string): string | null {\n    function getImageIfExists(url: string): Promise { \n      return new Promise((resolve, reject) => {\n        const img = new Image();\n        img.src = url;\n        img.onload = () => resolve(true);\n        img.onerror = () => resolve(false);\n      });\n    }\n    let testedUrl = null;\n    if (url) {\n      let imgTest = await getImageIfExists(url).catch(console.log);\n      if (imgTest === true) {\n        testedUrl = url;\n      } else {\n        throw `Image not found at url '${url}'`;\n      }\n    } \n    return testedUrl;\n  }\n\n\n\n\n\n\n\n  /**\n   * Return the year if positive or year BC if negative. (Deals with the year\n   * only.) \n   *\n   * Technically BC should be offset by one year but we told users to use\n   * negative numbers as years BC.\n   *\n   * Returns: Formatted string for year, with BC if the year was\n   * negative\n   */\n  dateToString(): string { \n    if (this.isClue) {\n      return \"Clue\";\n    } else {\n      let yearZero = new Date();\n      yearZero.setFullYear(0);\n\n      let displayYear = this.year;\n      if (this.date < yearZero) {\n        displayYear = `${-displayYear} bce`; \n      } \n      return displayYear;\n    }\n  }\n\n  // Return the date as YYYY year string.\n  get year(): string { return this.date.getFullYear(); }\n\n  set year(YYYY: string): void { \n    if (YYYY) {\n      this.date.setFullYear(YYYY); \n    } \n  }\n\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}