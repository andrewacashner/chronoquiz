{"ast":null,"code":"/**\n * Colors: This class holds the information for one color: red, green, blue\n * values plus a percentage of white to mix in.\n */\nexport default class RgbColorMix {\n  // integer percentage of white to mix in (50 = * 50%)\n\n  constructor(r, g, b, w) {\n    this.red = void 0;\n    // integer 0 <= n < 256\n    this.green = void 0;\n    // integer 0 <= n < 256\n    this.blue = void 0;\n    // integer 0 <= n < 256\n    this.percentWhite = void 0;\n    this.red = r;\n    this.green = g;\n    this.blue = b;\n    this.percentWhite = w; // as decimal, 0.5 not 50%\n  }\n\n  // Create CSS color (color-mix with rgb color)\n  // Returns: CSS color-mix expression\n  get css() {\n    let rgb = `rgb(${this.red}, ${this.green}, ${this.blue})`;\n    return `color-mix(in srgb, ${rgb}, ${this.percentWhite}% white)`;\n  }\n\n  /**\n   * List of all colors available in range.\n   * For each of red, blue, and green, iterate through values of primary with\n   * constant secondary and white values (tertiary color is zero).\n   */\n  static colorSpectrum(max = 256,\n  // Highest color value possible for each (RGB)\n  min = 0,\n  // Used for secondary color, \n  //    fixed value mixed in to each primary \n  white = 50 // Percent white to mix in, fixed for all \n  ) {\n    let reds = [];\n    let blues = [];\n    let greens = [];\n\n    // Increase red value relative to others to go red -> orange\n    for (let i = 0; i < max; ++i) {\n      reds.push([max, i, min, white]);\n    }\n\n    // *Decrease* green and blue value relative to others to continue in\n    // spectrum order \n    for (let i = max - 1; i >= 0; --i) {\n      greens.push([i, max, min, white]);\n      blues.push([min, i, max, white]);\n    }\n\n    // Combine the spectrums and create a color instance for each\n    let perms = [...reds, ...greens, ...blues];\n    let colors = perms.map(p => new RgbColorMix(...p));\n    return colors;\n  }\n\n  /**\n   * Get the CSS color string for a card at a given index, dividing the\n   * spectrum evenly by the total number of cards\n   * Returns CSS color string\n   */\n  static colorAtIndex(index,\n  // integer index of this card in array\n  length,\n  // integer length of the array\n  spectrum) {\n    let color;\n    if (length === 1) {\n      color = violet;\n    } else {\n      let interval = Math.floor(spectrum.length / length);\n      color = spectrum[index * interval];\n    }\n    return color;\n  }\n}","map":{"version":3,"names":["RgbColorMix","constructor","r","g","b","w","red","green","blue","percentWhite","css","rgb","colorSpectrum","max","min","white","reds","blues","greens","i","push","perms","colors","map","p","colorAtIndex","index","length","spectrum","color","violet","interval","Math","floor"],"sources":["/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/src/classes/RgbColorMix.tsx"],"sourcesContent":["/**\n * Colors: This class holds the information for one color: red, green, blue\n * values plus a percentage of white to mix in.\n */\nexport default class RgbColorMix {\n  red: number;          // integer 0 <= n < 256\n  green: number;        // integer 0 <= n < 256\n  blue: number;         // integer 0 <= n < 256\n  percentWhite: number; // integer percentage of white to mix in (50 = * 50%)\n\n  constructor(r: number, g: number, b: number, w: number) {\n    this.red = r;\n    this.green = g;\n    this.blue = b;\n    this.percentWhite = w; // as decimal, 0.5 not 50%\n  }\n\n  // Create CSS color (color-mix with rgb color)\n  // Returns: CSS color-mix expression\n  get css(): string {\n    let rgb = `rgb(${this.red}, ${this.green}, ${this.blue})`;\n    return `color-mix(in srgb, ${rgb}, ${this.percentWhite}% white)`;\n  }\n\n  /**\n   * List of all colors available in range.\n   * For each of red, blue, and green, iterate through values of primary with\n   * constant secondary and white values (tertiary color is zero).\n   */\n  static colorSpectrum(\n    max: number = 256, // Highest color value possible for each (RGB)\n    min: number = 0,   // Used for secondary color, \n                       //    fixed value mixed in to each primary \n    white: number = 50 // Percent white to mix in, fixed for all \n  ): Array<RgbColorMix> {\n    let reds = [];\n    let blues = [];\n    let greens = []\n\n    // Increase red value relative to others to go red -> orange\n    for (let i = 0; i < max; ++i) {\n      reds.push([max, i, min, white]);\n    }\n\n    // *Decrease* green and blue value relative to others to continue in\n    // spectrum order \n    for (let i = max - 1; i >= 0; --i) {\n      greens.push([i, max, min, white]);\n      blues.push([min, i, max, white]);\n    }\n\n    // Combine the spectrums and create a color instance for each\n    let perms = [...reds, ...greens, ...blues];\n    let colors = perms.map((p) => new RgbColorMix(...p));\n    return colors;\n  }\n\n  /**\n   * Get the CSS color string for a card at a given index, dividing the\n   * spectrum evenly by the total number of cards\n   * Returns CSS color string\n   */\n  static colorAtIndex(\n    index: number,  // integer index of this card in array\n    length: number, // integer length of the array\n    spectrum: Array<RgbColorMix>\n  ): string {\n    let color;\n    if (length === 1) {\n      color = violet;\n    } else {\n      let interval = Math.floor(spectrum.length / length);\n      color = spectrum[index * interval];\n    }\n    return color;\n  }\n}\n\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,eAAe,MAAMA,WAAW,CAAC;EAIT;;EAEtBC,WAAWA,CAACC,CAAS,EAAEC,CAAS,EAAEC,CAAS,EAAEC,CAAS,EAAE;IAAA,KALxDC,GAAG;IAAmB;IAAA,KACtBC,KAAK;IAAiB;IAAA,KACtBC,IAAI;IAAkB;IAAA,KACtBC,YAAY;IAGV,IAAI,CAACH,GAAG,GAAGJ,CAAC;IACZ,IAAI,CAACK,KAAK,GAAGJ,CAAC;IACd,IAAI,CAACK,IAAI,GAAGJ,CAAC;IACb,IAAI,CAACK,YAAY,GAAGJ,CAAC,CAAC,CAAC;EACzB;;EAEA;EACA;EACA,IAAIK,GAAGA,CAAA,EAAW;IAChB,IAAIC,GAAG,GAAI,OAAM,IAAI,CAACL,GAAI,KAAI,IAAI,CAACC,KAAM,KAAI,IAAI,CAACC,IAAK,GAAE;IACzD,OAAQ,sBAAqBG,GAAI,KAAI,IAAI,CAACF,YAAa,UAAS;EAClE;;EAEA;AACF;AACA;AACA;AACA;EACE,OAAOG,aAAaA,CAClBC,GAAW,GAAG,GAAG;EAAE;EACnBC,GAAW,GAAG,CAAC;EAAI;EACA;EACnBC,KAAa,GAAG,EAAE,CAAC;EAAA,EACC;IACpB,IAAIC,IAAI,GAAG,EAAE;IACb,IAAIC,KAAK,GAAG,EAAE;IACd,IAAIC,MAAM,GAAG,EAAE;;IAEf;IACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,GAAG,EAAE,EAAEM,CAAC,EAAE;MAC5BH,IAAI,CAACI,IAAI,CAAC,CAACP,GAAG,EAAEM,CAAC,EAAEL,GAAG,EAAEC,KAAK,CAAC,CAAC;IACjC;;IAEA;IACA;IACA,KAAK,IAAII,CAAC,GAAGN,GAAG,GAAG,CAAC,EAAEM,CAAC,IAAI,CAAC,EAAE,EAAEA,CAAC,EAAE;MACjCD,MAAM,CAACE,IAAI,CAAC,CAACD,CAAC,EAAEN,GAAG,EAAEC,GAAG,EAAEC,KAAK,CAAC,CAAC;MACjCE,KAAK,CAACG,IAAI,CAAC,CAACN,GAAG,EAAEK,CAAC,EAAEN,GAAG,EAAEE,KAAK,CAAC,CAAC;IAClC;;IAEA;IACA,IAAIM,KAAK,GAAG,CAAC,GAAGL,IAAI,EAAE,GAAGE,MAAM,EAAE,GAAGD,KAAK,CAAC;IAC1C,IAAIK,MAAM,GAAGD,KAAK,CAACE,GAAG,CAAEC,CAAC,IAAK,IAAIxB,WAAW,CAAC,GAAGwB,CAAC,CAAC,CAAC;IACpD,OAAOF,MAAM;EACf;;EAEA;AACF;AACA;AACA;AACA;EACE,OAAOG,YAAYA,CACjBC,KAAa;EAAG;EAChBC,MAAc;EAAE;EAChBC,QAA4B,EACpB;IACR,IAAIC,KAAK;IACT,IAAIF,MAAM,KAAK,CAAC,EAAE;MAChBE,KAAK,GAAGC,MAAM;IAChB,CAAC,MAAM;MACL,IAAIC,QAAQ,GAAGC,IAAI,CAACC,KAAK,CAACL,QAAQ,CAACD,MAAM,GAAGA,MAAM,CAAC;MACnDE,KAAK,GAAGD,QAAQ,CAACF,KAAK,GAAGK,QAAQ,CAAC;IACpC;IACA,OAAOF,KAAK;EACd;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}