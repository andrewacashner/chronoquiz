{"ast":null,"code":"import _classPrivateFieldLooseBase from \"/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";\nimport _classPrivateFieldLooseKey from \"/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";\nvar _Card;\nvar _safe = /*#__PURE__*/_classPrivateFieldLooseKey(\"safe\");\nvar _markSafe = /*#__PURE__*/_classPrivateFieldLooseKey(\"markSafe\");\nvar _sanitizeDate = /*#__PURE__*/_classPrivateFieldLooseKey(\"sanitizeDate\");\nvar _sanitizeInfo = /*#__PURE__*/_classPrivateFieldLooseKey(\"sanitizeInfo\");\nvar _sanitizeImg = /*#__PURE__*/_classPrivateFieldLooseKey(\"sanitizeImg\");\nexport default class Card {\n  // Each card gets the given info and a random unique identifier.\n  constructor({\n    isClue = true,\n    date,\n    info,\n    img,\n    color\n  }) {\n    Object.defineProperty(this, _markSafe, {\n      value: _markSafe2\n    });\n    this.isClue = void 0;\n    this.id = void 0;\n    this.date = void 0;\n    this.info = void 0;\n    this.img = void 0;\n    this.color = void 0;\n    Object.defineProperty(this, _safe, {\n      writable: true,\n      value: void 0\n    });\n    this.isClue = isClue;\n    this.id = crypto.randomUUID();\n    this.date = date;\n    this.info = info;\n    this.img = img;\n    this.color = color;\n    _classPrivateFieldLooseBase(this, _safe)[_safe] = false; // Has this card been sanitized?\n  }\n  get isSafe() {\n    return _classPrivateFieldLooseBase(this, _safe)[_safe];\n  }\n\n  /** Create a new card with sanitized input.\n   *\n   * - The date must be an integer string <= the current year (including\n   *   negative numbers).\n   * - The info is converted to plain text using textContent.\n   * - The image, if present, is downloaded and cached.\n   *\n   * The parameters are the same as for new Card().\n   *\n   * Returns {Card} - Card with validated content (with safe property set to\n   * true), or null if the input was invalid\n   */\n  static async newSafeCard({\n    isClue,\n    date,\n    info,\n    img,\n    color\n  }) {\n    try {\n      let cleanDate = _classPrivateFieldLooseBase(Card, _sanitizeDate)[_sanitizeDate](date);\n      let cleanInfo = _classPrivateFieldLooseBase(Card, _sanitizeInfo)[_sanitizeInfo](info);\n      let cleanImg = await _classPrivateFieldLooseBase(Card, _sanitizeImg)[_sanitizeImg](img).catch(e => console.error(e));\n\n      // The date is the only dealbreaker. We just skip a bad image link.\n      if (cleanDate) {\n        let card = new Card({\n          isClue: isClue,\n          date: cleanDate,\n          info: cleanInfo,\n          img: cleanImg,\n          color: color\n        });\n        _classPrivateFieldLooseBase(card, _markSafe)[_markSafe]();\n        return card;\n      } else {\n        throw new Error(`Could not sanitize card input with date '${date}', info '${info}'`);\n      }\n    } catch (e) {\n      console.error(e);\n    }\n  }\n\n  // PRIVATE METHODS\n  // Sanitize input \n}\n_Card = Card;\nfunction _markSafe2() {\n  _classPrivateFieldLooseBase(this, _safe)[_safe] = true;\n  return this;\n}\nfunction _sanitizeDate2(raw) {\n  try {\n    let numTest = Number(raw);\n    if (!isNaN(numTest) && Number.isInteger(numTest) && numTest <= new Date().getFullYear()) {\n      let date = new Date();\n      date.setFullYear(numTest);\n      return date;\n    } else {\n      throw new Error(`Bad date input ${raw}`);\n    }\n  } catch (e) {\n    console.error(e);\n  }\n}\nfunction _sanitizeInfo2(raw) {\n  let node = document.createElement(\"span\");\n  node.textContent = raw;\n  return node.textContent;\n}\nasync function _sanitizeImg2(url) {\n  function doesImageExist(url) {\n    return new Promise((resolve, reject) => {\n      const img = new Image();\n      img.src = url;\n      img.onload = () => resolve(true);\n      img.onerror = () => resolve(false);\n    });\n  }\n  if (!url) {\n    return null;\n  } else {\n    let imgTest = await doesImageExist(url).catch(e => console.log(err));\n    if (imgTest === true) {\n      return url;\n    } else {\n      throw new Error(`Image not found at url '${url}'`);\n    }\n  }\n}\nObject.defineProperty(Card, _sanitizeImg, {\n  value: _sanitizeImg2\n});\nObject.defineProperty(Card, _sanitizeInfo, {\n  value: _sanitizeInfo2\n});\nObject.defineProperty(Card, _sanitizeDate, {\n  value: _sanitizeDate2\n});","map":{"version":3,"names":["Card","constructor","isClue","date","info","img","color","Object","defineProperty","_markSafe","value","_markSafe2","id","_safe","writable","crypto","randomUUID","_classPrivateFieldLooseBase","isSafe","newSafeCard","cleanDate","_sanitizeDate","cleanInfo","_sanitizeInfo","cleanImg","_sanitizeImg","catch","e","console","error","card","Error","_Card","_sanitizeDate2","raw","numTest","Number","isNaN","isInteger","Date","getFullYear","setFullYear","_sanitizeInfo2","node","document","createElement","textContent","_sanitizeImg2","url","doesImageExist","Promise","resolve","reject","Image","src","onload","onerror","imgTest","log","err"],"sources":["/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/src/classes/Card.tsx"],"sourcesContent":["export default class Card {\n  isClue: boolean;\n  id: string;\n  date: Date;\n  info: string;\n  img: string;\n  color: string;\n  #safe: boolean;\n\n  // Each card gets the given info and a random unique identifier.\n  constructor({ isClue = true, date, info, img, color }: {\n    isClue?: boolean, // Is this a clue (true) or answer?\n    date?: number,    // Four-digit year of event\n    info?: string,    // Brief description of event\n    img?: string,     // Full URL of image\n    color?: string    // CSS color to be used in timeline\n  }) {\n    this.isClue = isClue;\n    this.id = crypto.randomUUID();\n    this.date = date;\n    this.info = info;\n    this.img = img;\n    this.color = color;\n    this.#safe = false; // Has this card been sanitized?\n  }\n\n  #markSafe(): Card {\n    this.#safe = true;\n    return this;\n  }\n\n  get isSafe(): boolean {\n    return this.#safe;\n  }\n\n  /** Create a new card with sanitized input.\n   *\n   * - The date must be an integer string <= the current year (including\n   *   negative numbers).\n   * - The info is converted to plain text using textContent.\n   * - The image, if present, is downloaded and cached.\n   *\n   * The parameters are the same as for new Card().\n   *\n   * Returns {Card} - Card with validated content (with safe property set to\n   * true), or null if the input was invalid\n   */\n  static async newSafeCard({ isClue, date, info, img, color }: {\n    isClue?: boolean, \n    date?: number, \n    info?: string, \n    img?: string, \n    color?: color\n  }): Card {\n    try {\n      let cleanDate = Card.#sanitizeDate(date);\n      let cleanInfo = Card.#sanitizeInfo(info);\n      let cleanImg = await Card.#sanitizeImg(img).catch(e => console.error(e));\n\n      // The date is the only dealbreaker. We just skip a bad image link.\n      if (cleanDate) {\n        let card = new Card({\n          isClue: isClue, \n          date: cleanDate, \n          info: cleanInfo, \n          img: cleanImg, \n          color: color\n        });\n        card.#markSafe();\n        return card;\n      } else {\n        throw new Error(`Could not sanitize card input with date '${date}', info '${info}'`);\n      }\n    } catch(e) {\n      console.error(e);\n    }\n  }\n\n  // PRIVATE METHODS\n  // Sanitize input \n  static #sanitizeDate(raw: string | number | Date): Date | null {\n    try {\n      let numTest = Number(raw);\n      if (!isNaN(numTest) \n        && Number.isInteger(numTest) \n        && numTest <= new Date().getFullYear()) {\n\n        let date = new Date();\n        date.setFullYear(numTest);\n        return date;\n      } else {\n        throw new Error(`Bad date input ${raw}`);\n      }\n    } catch(e) { \n      console.error(e);\n    }\n  }\n\n  static #sanitizeInfo(raw: string): string {\n    let node = document.createElement(\"span\");\n    node.textContent = raw;\n    return node.textContent;\n  }\n\n  static async #sanitizeImg(url: string): string | null {\n    function doesImageExist(url: string): boolean { \n      return new Promise((resolve, reject) => {\n        const img = new Image();\n        img.src = url;\n        img.onload = () => resolve(true);\n        img.onerror = () => resolve(false);\n      });\n    }\n    if (!url) {\n      return null;\n    } else {\n      let imgTest = await doesImageExist(url).catch(e => console.log(err));\n      if (imgTest === true) {\n        return url;\n      } else {\n        throw new Error(`Image not found at url '${url}'`);\n      }\n    } \n  }\n\n\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}