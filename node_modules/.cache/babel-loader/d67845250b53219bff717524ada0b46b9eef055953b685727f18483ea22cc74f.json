{"ast":null,"code":"var _jsxFileName = \"/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/src/components/Timeline.tsx\",\n  _s = $RefreshSig$();\nimport { useContext } from \"react\";\nimport TimelineContext from \"../store/TimelineContext\";\nimport Game from \"../classes/Game\";\nimport Card from \"./Card\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction isCardElement(el) {\n  return el.classList.contains(\"card\");\n}\n\n// Return a card element, if found at given coordinates; or null. \nfunction cardAtCoord(x, y) {\n  let elements = document.elementsFromPoint(x, y);\n  let card = elements.find(isCardElement);\n  return card || null;\n}\n\n// Get the center point between two coordinates.\nfunction midpoint(a,\n// smaller (left edge)\nb) {\n  return (b - a) / 2 + a;\n}\n\n// TODO redo without queryselector?\n\n/**\n * Given an event (from a drop), start from its coordinates and search\n * to the right until a card element is found. The card must be dropped to\n * left of the midpoint of the card.\n * Return the answer card or null.\n */\nfunction findFirstCardToRight(event) {\n  console.log(`Card dropped with pointer at (${event.clientX}, ${event.clientY})`);\n\n  // Search along the timeline bar regardless of where the drop was vertically\n  let timelineBar = document.querySelector(\"div.scrollingTimeline hr\");\n  let y = timelineBar.getBoundingClientRect().top;\n  console.log(\"Looking for nearest card to timeline drop point\");\n  let max = document.documentElement.clientWidth;\n  let card = null;\n  for (let x = event.clientX; x < max; ++x) {\n    card = cardAtCoord(x, y);\n    if (card) {\n      let bounds = card.getBoundingClientRect();\n      let center = midpoint(bounds.left, bounds.right);\n      if (x <= center) break;\n    }\n  }\n  return card;\n}\nexport default function Timeline() {\n  _s();\n  let context = useContext(TimelineContext);\n  let [game, setGame] = [context.get, context.set];\n  let timeline = game.timeline;\n\n  // Allow to move by dragging. Insert gap to the left of a card when the drag\n  // point is in range to guess this card.\n  function dragoverHandler(event) {\n    event.preventDefault();\n    let bounds = event.target.getBoundingClientRect();\n    let center = midpoint(bounds.left, bounds.right);\n    if (event.clientX <= center) {\n      console.log(\"In range\");\n      let cardUnderDrag = cardAtCoord(event.clientX, event.clientY);\n      if (cardUnderDrag) {\n        timeline = timeline.expandAtId(cardUnderDrag.id), setGame(prevGame => new Game(prevGame.setTimeline(timeline)));\n      }\n    }\n    event.dataTransfer.effectAllowed = \"move\";\n  }\n  function dragleaveHandler(event) {\n    let el = event.target;\n    if (isCardElement(el)) {\n      timeline = timeline.resetAtId(el.id);\n      setGame(prevGame => new Game(prevGame.setTimeline(timeline)));\n    }\n  }\n\n  /**\n   * When the user drops a card onto a timeline card, find the closest card,\n   * test if the date on the clue is between that card and its previous\n   * neighbor (if there is one); if so insert the card and increment the\n   * score; if not, do not insert the card and decrement the score.\n   */\n  function dropHandler(event) {\n    // Is the given clue between a given answer card and the one before it?\n    function isClueBetweenDates(clue,\n    // Dropped card\n    guess,\n    // Card that clue was dropped onto\n    preGuess) {\n      let clueDate = clue.date;\n      let guessDate = guess.date;\n      let isBeforeGuess = clueDate <= guessDate;\n      let noPreGuess = !preGuess;\n      let isAfterPreGuess = preGuess && clueDate >= preGuess.date;\n      let isAfterAnyPreGuess = noPreGuess || isAfterPreGuess;\n      return isBeforeGuess && isAfterAnyPreGuess;\n    }\n    event.preventDefault();\n\n    // Find nearest answer (first card found to right of click) to compare\n    let clues = game.clues;\n    let clue = clues.last();\n    let guessElement = findFirstCardToRight(event);\n    let guessID = guessElement === null || guessElement === void 0 ? void 0 : guessElement.id;\n    let guessIndex = timeline.findIndexById(guessID);\n    if (guessID && guessIndex !== -1) {\n      let guess = timeline.at(guessIndex);\n      // TODO put this logic in \"isClueBetweenDates\"\n      let beforeGuess = guessIndex > 0 ? timeline.at(guessIndex - 1) : null;\n      if (isClueBetweenDates(clue, guess, beforeGuess)) {\n        console.log(\"Correct: ++Score\");\n        clue.flash = false;\n        setGame(prevGame => new Game(prevGame.moveCurrentClueToTimeline().incrementScore()));\n      } else {\n        console.log(\"Incorrect: --Score\");\n        clue.flash = true;\n        // TODO apparently clue is not a Clue instance at this point?\n        setGame(prevGame => new Game(prevGame.setClues(clues).resetTimelineMargins().decrementScore()));\n      }\n    } else {\n      console.log(\"No card found at drop location\");\n    }\n  }\n  let dragDropInterface = {\n    onDrop: dropHandler,\n    onDragOver: dragoverHandler,\n    onDragLeave: dragleaveHandler\n  };\n  const timelineWidth = {\n    style: {\n      width: `calc(${timeline.length} * (var(--card-width) + var(--card-margin)) + 4 * var(--card-margin)`\n    }\n  };\n  const windowWidth = document.documentElement.clientWidth;\n  const ruleWidth = timelineWidth > windowWidth ? timelineWidth : null;\n  if (game.isActive) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"scrollingTimeline\",\n      children: [/*#__PURE__*/_jsxDEV(\"hr\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 165,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"timelineBar\",\n        ...timelineWidth,\n        children: [/*#__PURE__*/_jsxDEV(\"hr\", {\n          ...ruleWidth\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 167,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"timeline\",\n          ...dragDropInterface,\n          children: timeline.map(card => /*#__PURE__*/_jsxDEV(Card, {\n            children: card\n          }, card.id, false, {\n            fileName: _jsxFileName,\n            lineNumber: 169,\n            columnNumber: 35\n          }, this))\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 168,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 166,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 164,\n      columnNumber: 7\n    }, this);\n  }\n}\n_s(Timeline, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n_c = Timeline;\nvar _c;\n$RefreshReg$(_c, \"Timeline\");","map":{"version":3,"names":["useContext","TimelineContext","Game","Card","jsxDEV","_jsxDEV","isCardElement","el","classList","contains","cardAtCoord","x","y","elements","document","elementsFromPoint","card","find","midpoint","a","b","findFirstCardToRight","event","console","log","clientX","clientY","timelineBar","querySelector","getBoundingClientRect","top","max","documentElement","clientWidth","bounds","center","left","right","Timeline","_s","context","game","setGame","get","set","timeline","dragoverHandler","preventDefault","target","cardUnderDrag","expandAtId","id","prevGame","setTimeline","dataTransfer","effectAllowed","dragleaveHandler","resetAtId","dropHandler","isClueBetweenDates","clue","guess","preGuess","clueDate","date","guessDate","isBeforeGuess","noPreGuess","isAfterPreGuess","isAfterAnyPreGuess","clues","last","guessElement","guessID","guessIndex","findIndexById","at","beforeGuess","flash","moveCurrentClueToTimeline","incrementScore","setClues","resetTimelineMargins","decrementScore","dragDropInterface","onDrop","onDragOver","onDragLeave","timelineWidth","style","width","length","windowWidth","ruleWidth","isActive","className","children","fileName","_jsxFileName","lineNumber","columnNumber","map","_c","$RefreshReg$"],"sources":["/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/src/components/Timeline.tsx"],"sourcesContent":["import { useContext } from \"react\";\nimport TimelineContext from \"../store/TimelineContext\";\n\nimport Game from \"../classes/Game\";\n\nimport Card from \"./Card\";\n\nfunction isCardElement(el: HTMLElement): boolean {\n  return el.classList.contains(\"card\");\n}\n\n// Return a card element, if found at given coordinates; or null. \nfunction cardAtCoord(x: number, y: number): HTMLElement {\n  let elements = document.elementsFromPoint(x, y);\n  let card = elements.find(isCardElement);\n  return card || null;\n}\n\n// Get the center point between two coordinates.\nfunction midpoint(\n  a: number, // smaller (left edge)\n  b: number  // larger (right edge)\n): number {\n  return (b - a) / 2 + a;\n}\n \n\n// TODO redo without queryselector?\n\n/**\n * Given an event (from a drop), start from its coordinates and search\n * to the right until a card element is found. The card must be dropped to\n * left of the midpoint of the card.\n * Return the answer card or null.\n */\nfunction findFirstCardToRight(event: React.DropEvent<HTMLElement>): HTMLElement {\n  console.log(`Card dropped with pointer at (${event.clientX}, ${event.clientY})`);\n\n  // Search along the timeline bar regardless of where the drop was vertically\n  let timelineBar = document.querySelector(\"div.scrollingTimeline hr\");\n  let y = timelineBar.getBoundingClientRect().top;\n\n  console.log(\"Looking for nearest card to timeline drop point\");\n  let max = document.documentElement.clientWidth; \n\n  let card = null;\n  for (let x = event.clientX; x < max; ++x) {\n    card = cardAtCoord(x, y);\n    if (card) {\n      let bounds = card.getBoundingClientRect();\n      let center = midpoint(bounds.left, bounds.right);\n      if (x <= center) break;\n    }\n  }\n\n  return card;\n}\n\n\n\nexport default function Timeline() {\n  let context = useContext(TimelineContext);\n  let [game, setGame] = [context.get, context.set];\n  \n  let timeline = game.timeline;\n\n  // Allow to move by dragging. Insert gap to the left of a card when the drag\n  // point is in range to guess this card.\n  function dragoverHandler(event: React.DragEvent<HTMLElement>): void {\n    event.preventDefault();\n  \n    let bounds = event.target.getBoundingClientRect();\n    let center = midpoint(bounds.left, bounds.right);\n  \n    if (event.clientX <= center) {\n      console.log(\"In range\");\n      let cardUnderDrag = cardAtCoord(event.clientX, event.clientY);\n      if (cardUnderDrag) {\n        timeline = timeline.expandAtId(cardUnderDrag.id),\n        setGame(prevGame => new Game(prevGame.setTimeline(timeline)));\n      }\n    }\n    event.dataTransfer.effectAllowed = \"move\";\n  }\n  \n  function dragleaveHandler(event: React.DragEvent<HTMLElement>): void {\n    let el = event.target;\n    if (isCardElement(el)) {\n      timeline = timeline.resetAtId(el.id);\n      setGame(prevGame => new Game(prevGame.setTimeline(timeline)));\n    }\n  }\n\n  /**\n   * When the user drops a card onto a timeline card, find the closest card,\n   * test if the date on the clue is between that card and its previous\n   * neighbor (if there is one); if so insert the card and increment the\n   * score; if not, do not insert the card and decrement the score.\n   */\n  function dropHandler(event: React.DropEvent<HTMLElement>): void {\n    \n    // Is the given clue between a given answer card and the one before it?\n    function isClueBetweenDates(\n      clue: Card,            // Dropped card\n      guess: Card,           // Card that clue was dropped onto\n      preGuess: Card | null  // previous card of guess, if exists\n    ): boolean {\n      let clueDate = clue.date\n      let guessDate = guess.date\n      let isBeforeGuess = clueDate <= guessDate;\n    \n      let noPreGuess = !preGuess;\n      let isAfterPreGuess = preGuess && (clueDate >= preGuess.date);\n      let isAfterAnyPreGuess = noPreGuess || isAfterPreGuess;\n    \n      return isBeforeGuess && isAfterAnyPreGuess;\n    }\n\n    event.preventDefault();\n\n    // Find nearest answer (first card found to right of click) to compare\n    let clues = game.clues;\n    let clue = clues.last();\n    let guessElement = findFirstCardToRight(event);\n    let guessID = guessElement?.id;\n    let guessIndex = timeline.findIndexById(guessID);\n\n    if (guessID && guessIndex !== -1) {\n      let guess = timeline.at(guessIndex);\n      // TODO put this logic in \"isClueBetweenDates\"\n      let beforeGuess = (guessIndex > 0) ? timeline.at(guessIndex - 1) : null;\n\n      if (isClueBetweenDates(clue, guess, beforeGuess)) {\n        console.log(\"Correct: ++Score\");\n        clue.flash = false;\n        setGame(prevGame => new Game(prevGame.moveCurrentClueToTimeline().incrementScore()));\n      } else {\n        console.log(\"Incorrect: --Score\");\n        clue.flash = true;\n        // TODO apparently clue is not a Clue instance at this point?\n        setGame(prevGame => new Game(prevGame.setClues(clues).resetTimelineMargins().decrementScore()));\n      }\n    } else {\n      console.log(\"No card found at drop location\");\n    }\n  }\n\n  let dragDropInterface = {\n    onDrop: dropHandler,\n    onDragOver: dragoverHandler,\n    onDragLeave: dragleaveHandler\n  } \n\n  const timelineWidth = {\n    style: { width: \n      `calc(${timeline.length} * (var(--card-width) + var(--card-margin)) + 4 * var(--card-margin)`\n    }\n  }\n  const windowWidth = document.documentElement.clientWidth;\n  const ruleWidth = (timelineWidth > windowWidth) ? timelineWidth : null;\n\n  if (game.isActive) {\n    return(\n      <div className=\"scrollingTimeline\">\n        <hr />\n        <div className=\"timelineBar\" {...timelineWidth} >\n          <hr {...ruleWidth} />\n          <div className=\"timeline\" {...dragDropInterface}>\n            {timeline.map(card => <Card key={card.id}>{card}</Card>)}\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n"],"mappings":";;AAAA,SAASA,UAAU,QAAQ,OAAO;AAClC,OAAOC,eAAe,MAAM,0BAA0B;AAEtD,OAAOC,IAAI,MAAM,iBAAiB;AAElC,OAAOC,IAAI,MAAM,QAAQ;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAE1B,SAASC,aAAaA,CAACC,EAAe,EAAW;EAC/C,OAAOA,EAAE,CAACC,SAAS,CAACC,QAAQ,CAAC,MAAM,CAAC;AACtC;;AAEA;AACA,SAASC,WAAWA,CAACC,CAAS,EAAEC,CAAS,EAAe;EACtD,IAAIC,QAAQ,GAAGC,QAAQ,CAACC,iBAAiB,CAACJ,CAAC,EAAEC,CAAC,CAAC;EAC/C,IAAII,IAAI,GAAGH,QAAQ,CAACI,IAAI,CAACX,aAAa,CAAC;EACvC,OAAOU,IAAI,IAAI,IAAI;AACrB;;AAEA;AACA,SAASE,QAAQA,CACfC,CAAS;AAAE;AACXC,CAAS,EACD;EACR,OAAO,CAACA,CAAC,GAAGD,CAAC,IAAI,CAAC,GAAGA,CAAC;AACxB;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,oBAAoBA,CAACC,KAAmC,EAAe;EAC9EC,OAAO,CAACC,GAAG,CAAE,iCAAgCF,KAAK,CAACG,OAAQ,KAAIH,KAAK,CAACI,OAAQ,GAAE,CAAC;;EAEhF;EACA,IAAIC,WAAW,GAAGb,QAAQ,CAACc,aAAa,CAAC,0BAA0B,CAAC;EACpE,IAAIhB,CAAC,GAAGe,WAAW,CAACE,qBAAqB,CAAC,CAAC,CAACC,GAAG;EAE/CP,OAAO,CAACC,GAAG,CAAC,iDAAiD,CAAC;EAC9D,IAAIO,GAAG,GAAGjB,QAAQ,CAACkB,eAAe,CAACC,WAAW;EAE9C,IAAIjB,IAAI,GAAG,IAAI;EACf,KAAK,IAAIL,CAAC,GAAGW,KAAK,CAACG,OAAO,EAAEd,CAAC,GAAGoB,GAAG,EAAE,EAAEpB,CAAC,EAAE;IACxCK,IAAI,GAAGN,WAAW,CAACC,CAAC,EAAEC,CAAC,CAAC;IACxB,IAAII,IAAI,EAAE;MACR,IAAIkB,MAAM,GAAGlB,IAAI,CAACa,qBAAqB,CAAC,CAAC;MACzC,IAAIM,MAAM,GAAGjB,QAAQ,CAACgB,MAAM,CAACE,IAAI,EAAEF,MAAM,CAACG,KAAK,CAAC;MAChD,IAAI1B,CAAC,IAAIwB,MAAM,EAAE;IACnB;EACF;EAEA,OAAOnB,IAAI;AACb;AAIA,eAAe,SAASsB,QAAQA,CAAA,EAAG;EAAAC,EAAA;EACjC,IAAIC,OAAO,GAAGxC,UAAU,CAACC,eAAe,CAAC;EACzC,IAAI,CAACwC,IAAI,EAAEC,OAAO,CAAC,GAAG,CAACF,OAAO,CAACG,GAAG,EAAEH,OAAO,CAACI,GAAG,CAAC;EAEhD,IAAIC,QAAQ,GAAGJ,IAAI,CAACI,QAAQ;;EAE5B;EACA;EACA,SAASC,eAAeA,CAACxB,KAAmC,EAAQ;IAClEA,KAAK,CAACyB,cAAc,CAAC,CAAC;IAEtB,IAAIb,MAAM,GAAGZ,KAAK,CAAC0B,MAAM,CAACnB,qBAAqB,CAAC,CAAC;IACjD,IAAIM,MAAM,GAAGjB,QAAQ,CAACgB,MAAM,CAACE,IAAI,EAAEF,MAAM,CAACG,KAAK,CAAC;IAEhD,IAAIf,KAAK,CAACG,OAAO,IAAIU,MAAM,EAAE;MAC3BZ,OAAO,CAACC,GAAG,CAAC,UAAU,CAAC;MACvB,IAAIyB,aAAa,GAAGvC,WAAW,CAACY,KAAK,CAACG,OAAO,EAAEH,KAAK,CAACI,OAAO,CAAC;MAC7D,IAAIuB,aAAa,EAAE;QACjBJ,QAAQ,GAAGA,QAAQ,CAACK,UAAU,CAACD,aAAa,CAACE,EAAE,CAAC,EAChDT,OAAO,CAACU,QAAQ,IAAI,IAAIlD,IAAI,CAACkD,QAAQ,CAACC,WAAW,CAACR,QAAQ,CAAC,CAAC,CAAC;MAC/D;IACF;IACAvB,KAAK,CAACgC,YAAY,CAACC,aAAa,GAAG,MAAM;EAC3C;EAEA,SAASC,gBAAgBA,CAAClC,KAAmC,EAAQ;IACnE,IAAIf,EAAE,GAAGe,KAAK,CAAC0B,MAAM;IACrB,IAAI1C,aAAa,CAACC,EAAE,CAAC,EAAE;MACrBsC,QAAQ,GAAGA,QAAQ,CAACY,SAAS,CAAClD,EAAE,CAAC4C,EAAE,CAAC;MACpCT,OAAO,CAACU,QAAQ,IAAI,IAAIlD,IAAI,CAACkD,QAAQ,CAACC,WAAW,CAACR,QAAQ,CAAC,CAAC,CAAC;IAC/D;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,SAASa,WAAWA,CAACpC,KAAmC,EAAQ;IAE9D;IACA,SAASqC,kBAAkBA,CACzBC,IAAU;IAAa;IACvBC,KAAW;IAAY;IACvBC,QAAqB,EACZ;MACT,IAAIC,QAAQ,GAAGH,IAAI,CAACI,IAAI;MACxB,IAAIC,SAAS,GAAGJ,KAAK,CAACG,IAAI;MAC1B,IAAIE,aAAa,GAAGH,QAAQ,IAAIE,SAAS;MAEzC,IAAIE,UAAU,GAAG,CAACL,QAAQ;MAC1B,IAAIM,eAAe,GAAGN,QAAQ,IAAKC,QAAQ,IAAID,QAAQ,CAACE,IAAK;MAC7D,IAAIK,kBAAkB,GAAGF,UAAU,IAAIC,eAAe;MAEtD,OAAOF,aAAa,IAAIG,kBAAkB;IAC5C;IAEA/C,KAAK,CAACyB,cAAc,CAAC,CAAC;;IAEtB;IACA,IAAIuB,KAAK,GAAG7B,IAAI,CAAC6B,KAAK;IACtB,IAAIV,IAAI,GAAGU,KAAK,CAACC,IAAI,CAAC,CAAC;IACvB,IAAIC,YAAY,GAAGnD,oBAAoB,CAACC,KAAK,CAAC;IAC9C,IAAImD,OAAO,GAAGD,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAErB,EAAE;IAC9B,IAAIuB,UAAU,GAAG7B,QAAQ,CAAC8B,aAAa,CAACF,OAAO,CAAC;IAEhD,IAAIA,OAAO,IAAIC,UAAU,KAAK,CAAC,CAAC,EAAE;MAChC,IAAIb,KAAK,GAAGhB,QAAQ,CAAC+B,EAAE,CAACF,UAAU,CAAC;MACnC;MACA,IAAIG,WAAW,GAAIH,UAAU,GAAG,CAAC,GAAI7B,QAAQ,CAAC+B,EAAE,CAACF,UAAU,GAAG,CAAC,CAAC,GAAG,IAAI;MAEvE,IAAIf,kBAAkB,CAACC,IAAI,EAAEC,KAAK,EAAEgB,WAAW,CAAC,EAAE;QAChDtD,OAAO,CAACC,GAAG,CAAC,kBAAkB,CAAC;QAC/BoC,IAAI,CAACkB,KAAK,GAAG,KAAK;QAClBpC,OAAO,CAACU,QAAQ,IAAI,IAAIlD,IAAI,CAACkD,QAAQ,CAAC2B,yBAAyB,CAAC,CAAC,CAACC,cAAc,CAAC,CAAC,CAAC,CAAC;MACtF,CAAC,MAAM;QACLzD,OAAO,CAACC,GAAG,CAAC,oBAAoB,CAAC;QACjCoC,IAAI,CAACkB,KAAK,GAAG,IAAI;QACjB;QACApC,OAAO,CAACU,QAAQ,IAAI,IAAIlD,IAAI,CAACkD,QAAQ,CAAC6B,QAAQ,CAACX,KAAK,CAAC,CAACY,oBAAoB,CAAC,CAAC,CAACC,cAAc,CAAC,CAAC,CAAC,CAAC;MACjG;IACF,CAAC,MAAM;MACL5D,OAAO,CAACC,GAAG,CAAC,gCAAgC,CAAC;IAC/C;EACF;EAEA,IAAI4D,iBAAiB,GAAG;IACtBC,MAAM,EAAE3B,WAAW;IACnB4B,UAAU,EAAExC,eAAe;IAC3ByC,WAAW,EAAE/B;EACf,CAAC;EAED,MAAMgC,aAAa,GAAG;IACpBC,KAAK,EAAE;MAAEC,KAAK,EACX,QAAO7C,QAAQ,CAAC8C,MAAO;IAC1B;EACF,CAAC;EACD,MAAMC,WAAW,GAAG9E,QAAQ,CAACkB,eAAe,CAACC,WAAW;EACxD,MAAM4D,SAAS,GAAIL,aAAa,GAAGI,WAAW,GAAIJ,aAAa,GAAG,IAAI;EAEtE,IAAI/C,IAAI,CAACqD,QAAQ,EAAE;IACjB,oBACEzF,OAAA;MAAK0F,SAAS,EAAC,mBAAmB;MAAAC,QAAA,gBAChC3F,OAAA;QAAA4F,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAK,CAAC,eACN/F,OAAA;QAAK0F,SAAS,EAAC,aAAa;QAAA,GAAKP,aAAa;QAAAQ,QAAA,gBAC5C3F,OAAA;UAAA,GAAQwF;QAAS;UAAAI,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAAG,CAAC,eACrB/F,OAAA;UAAK0F,SAAS,EAAC,UAAU;UAAA,GAAKX,iBAAiB;UAAAY,QAAA,EAC5CnD,QAAQ,CAACwD,GAAG,CAACrF,IAAI,iBAAIX,OAAA,CAACF,IAAI;YAAA6F,QAAA,EAAgBhF;UAAI,GAAdA,IAAI,CAACmC,EAAE;YAAA8C,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,OAAc,CAAC;QAAC;UAAAH,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OACrD,CAAC;MAAA;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OACH,CAAC;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACH,CAAC;EAEV;AACF;AAAC7D,EAAA,CAlHuBD,QAAQ;AAAAgE,EAAA,GAARhE,QAAQ;AAAA,IAAAgE,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}