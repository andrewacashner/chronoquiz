{"ast":null,"code":"import{useContext}from\"react\";import TimelineContext from\"../store/TimelineContext\";import Game from\"../classes/Game\";import Card from\"./Card\";import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";function isCardElement(el){return el.classList.contains(\"card\");}// Return a card element, if found at given coordinates; or null. \nfunction cardAtCoord(x,y){let elements=document.elementsFromPoint(x,y);let card=elements.find(isCardElement);return card||null;}// Get the center point between two coordinates.\nfunction midpoint(a,// smaller (left edge)\nb){return(b-a)/2+a;}// TODO redo without queryselector?\n/**\n * Given an event (from a drop), start from its coordinates and search\n * to the right until a card element is found. The card must be dropped to\n * left of the midpoint of the card.\n * Return the answer card or null.\n */function findFirstCardToRight(event){console.log(\"Card dropped with pointer at (\".concat(event.clientX,\", \").concat(event.clientY,\")\"));// Search along the timeline bar regardless of where the drop was vertically\nlet timelineBar=document.querySelector(\"div.scrollingTimeline hr\");let y=timelineBar.getBoundingClientRect().top;console.log(\"Looking for nearest card to timeline drop point\");let max=document.documentElement.clientWidth;let card=null;for(let x=event.clientX;x<max;++x){card=cardAtCoord(x,y);if(card){let bounds=card.getBoundingClientRect();let center=midpoint(bounds.left,bounds.right);if(x<=center)break;}}return card;}export default function Clues(){let context=useContext(TimelineContext);let[game,setGame]=[context.get,context.set];let timeline=game.timeline;// Allow to move by dragging. Insert gap to the left of a card when the drag\n// point is in range to guess this card.\nfunction dragoverHandler(event){event.preventDefault();let bounds=event.target.getBoundingClientRect();let center=midpoint(bounds.left,bounds.right);if(event.clientX<=center){console.log(\"In range\");let cardUnderDrag=cardAtCoord(event.clientX,event.clientY);if(cardUnderDrag){let match=timeline.findById(cardUnderDrag.id);match.expand=true;setGame(prevGame=>new Game({timeline:timeline,...prevGame}));}}event.dataTransfer.effectAllowed=\"move\";}function dragleaveHandler(event){let el=event.target;if(isCardElement(el)){let match=timeline.findById(el.id);match.expand=false;setGame(prevGame=>new Game({timeline:timeline.resetMargins(),...prevGame}));}}/**\n   * When the user drops a card onto a timeline card, find the closest card,\n   * test if the date on the clue is between that card and its previous\n   * neighbor (if there is one); if so insert the card and increment the\n   * score; if not, do not insert the card and decrement the score.\n   */function dropHandler(event){// Is the given clue between a given answer card and the one before it?\nfunction isClueBetweenDates(clue,// Dropped card\nguess,// Card that clue was dropped onto\npreGuess){let clueDate=clue.date;let guessDate=guess.date;let isBeforeGuess=clueDate<=guessDate;let noPreGuess=!preGuess;let isAfterPreGuess=preGuess&&clueDate>=preGuess.date;let isAfterAnyPreGuess=noPreGuess||isAfterPreGuess;return isBeforeGuess&&isAfterAnyPreGuess;}event.preventDefault();// Find nearest answer (first card found to right of click) to compare\nlet clues=game.clues;let clue=clues.last();let guessElement=findFirstCardToRight(event);let guessID=guessElement===null||guessElement===void 0?void 0:guessElement.id;let guessIndex=timeline.findIndexById(guessID);if(guessID&&guessIndex!==-1){let guess=timeline.at(guessIndex);// TODO put this logic in \"isClueBetweenDates\"\nlet beforeGuess=guessIndex>0?timeline.at(guessIndex-1):null;if(isClueBetweenDates(clue,guess,beforeGuess)){console.log(\"Correct: ++Score\");clue.flash=false;setGame(prevGame=>prevGame.copyWithNextClue().incrementScore());}else{console.log(\"Incorrect: --Score\");clue.flash=true;// TODO apparently clue is not a Clue instance at this point?\nsetGame(prevGame=>new Game({clues:clues,timeline:prevGame.timeline.resetMargins(),...prevGame}));setGame(prevGame=>prevGame.decrementScore());}}else{console.log(\"No card found at drop location\");}}let dragDropInterface={onDrop:dropHandler,onDragOver:dragoverHandler,onDragLeave:dragleaveHandler};const timelineWidth={style:{width:\"calc(\".concat(timeline.length,\" * (var(--card-width) + var(--card-margin)) + 4 * var(--card-margin)\")}};const windowWidth=document.documentElement.clientWidth;const ruleWidth=timelineWidth>windowWidth?timelineWidth:null;if(game.isActive){return/*#__PURE__*/_jsxs(\"div\",{className:\"scrollingTimeline\",children:[/*#__PURE__*/_jsx(\"hr\",{}),/*#__PURE__*/_jsxs(\"div\",{className:\"timelineBar\",...timelineWidth,children:[/*#__PURE__*/_jsx(\"hr\",{...ruleWidth}),/*#__PURE__*/_jsx(\"div\",{className:\"timeline\",...dragDropInterface,children:timeline.map(card=>/*#__PURE__*/_jsx(Card,{children:card},card.id))})]})]});}}","map":{"version":3,"names":["useContext","TimelineContext","Game","Card","jsx","_jsx","jsxs","_jsxs","isCardElement","el","classList","contains","cardAtCoord","x","y","elements","document","elementsFromPoint","card","find","midpoint","a","b","findFirstCardToRight","event","console","log","concat","clientX","clientY","timelineBar","querySelector","getBoundingClientRect","top","max","documentElement","clientWidth","bounds","center","left","right","Clues","context","game","setGame","get","set","timeline","dragoverHandler","preventDefault","target","cardUnderDrag","match","findById","id","expand","prevGame","dataTransfer","effectAllowed","dragleaveHandler","resetMargins","dropHandler","isClueBetweenDates","clue","guess","preGuess","clueDate","date","guessDate","isBeforeGuess","noPreGuess","isAfterPreGuess","isAfterAnyPreGuess","clues","last","guessElement","guessID","guessIndex","findIndexById","at","beforeGuess","flash","copyWithNextClue","incrementScore","decrementScore","dragDropInterface","onDrop","onDragOver","onDragLeave","timelineWidth","style","width","length","windowWidth","ruleWidth","isActive","className","children","map"],"sources":["/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/src/components/Timeline.tsx"],"sourcesContent":["import { useContext } from \"react\";\nimport TimelineContext from \"../store/TimelineContext\";\n\nimport Game from \"../classes/Game\";\n\nimport Card from \"./Card\";\n\nfunction isCardElement(el: HTMLElement): boolean {\n  return el.classList.contains(\"card\");\n}\n\n// Return a card element, if found at given coordinates; or null. \nfunction cardAtCoord(x: number, y: number): HTMLElement {\n  let elements = document.elementsFromPoint(x, y);\n  let card = elements.find(isCardElement);\n  return card || null;\n}\n\n// Get the center point between two coordinates.\nfunction midpoint(\n  a: number, // smaller (left edge)\n  b: number  // larger (right edge)\n): number {\n  return (b - a) / 2 + a;\n}\n \n\n// TODO redo without queryselector?\n\n/**\n * Given an event (from a drop), start from its coordinates and search\n * to the right until a card element is found. The card must be dropped to\n * left of the midpoint of the card.\n * Return the answer card or null.\n */\nfunction findFirstCardToRight(event: React.DropEvent<HTMLElement>): HTMLElement {\n  console.log(`Card dropped with pointer at (${event.clientX}, ${event.clientY})`);\n\n  // Search along the timeline bar regardless of where the drop was vertically\n  let timelineBar = document.querySelector(\"div.scrollingTimeline hr\");\n  let y = timelineBar.getBoundingClientRect().top;\n\n  console.log(\"Looking for nearest card to timeline drop point\");\n  let max = document.documentElement.clientWidth; \n\n  let card = null;\n  for (let x = event.clientX; x < max; ++x) {\n    card = cardAtCoord(x, y);\n    if (card) {\n      let bounds = card.getBoundingClientRect();\n      let center = midpoint(bounds.left, bounds.right);\n      if (x <= center) break;\n    }\n  }\n\n  return card;\n}\n\n\n\nexport default function Clues() {\n  let context = useContext(TimelineContext);\n  let [game, setGame] = [context.get, context.set];\n  let timeline = game.timeline;\n\n  // Allow to move by dragging. Insert gap to the left of a card when the drag\n  // point is in range to guess this card.\n  function dragoverHandler(event: React.DragEvent<HTMLElement>): void {\n    event.preventDefault();\n  \n    let bounds = event.target.getBoundingClientRect();\n    let center = midpoint(bounds.left, bounds.right);\n  \n    if (event.clientX <= center) {\n      console.log(\"In range\");\n      let cardUnderDrag = cardAtCoord(event.clientX, event.clientY);\n      if (cardUnderDrag) {\n        let match = timeline.findById(cardUnderDrag.id);\n        match.expand = true;\n        setGame(prevGame => new Game({ timeline: timeline, ...prevGame }));\n      }\n    }\n    event.dataTransfer.effectAllowed = \"move\";\n  }\n  \n  function dragleaveHandler(event: React.DragEvent<HTMLElement>): void {\n    let el = event.target;\n    if (isCardElement(el)) {\n      let match = timeline.findById(el.id);\n      match.expand = false;\n      setGame(prevGame => new Game({ timeline: timeline.resetMargins(), \n                                   ...prevGame }));\n    }\n  }\n\n  /**\n   * When the user drops a card onto a timeline card, find the closest card,\n   * test if the date on the clue is between that card and its previous\n   * neighbor (if there is one); if so insert the card and increment the\n   * score; if not, do not insert the card and decrement the score.\n   */\n  function dropHandler(event: React.DropEvent<HTMLElement>): void {\n    \n    // Is the given clue between a given answer card and the one before it?\n    function isClueBetweenDates(\n      clue: Card,            // Dropped card\n      guess: Card,           // Card that clue was dropped onto\n      preGuess: Card | null  // previous card of guess, if exists\n    ): boolean {\n      let clueDate = clue.date\n      let guessDate = guess.date\n      let isBeforeGuess = clueDate <= guessDate;\n    \n      let noPreGuess = !preGuess;\n      let isAfterPreGuess = preGuess && (clueDate >= preGuess.date);\n      let isAfterAnyPreGuess = noPreGuess || isAfterPreGuess;\n    \n      return isBeforeGuess && isAfterAnyPreGuess;\n    }\n\n    event.preventDefault();\n\n    // Find nearest answer (first card found to right of click) to compare\n    let clues = game.clues;\n    let clue = clues.last();\n    let guessElement = findFirstCardToRight(event);\n    let guessID = guessElement?.id;\n    let guessIndex = timeline.findIndexById(guessID);\n\n    if (guessID && guessIndex !== -1) {\n      let guess = timeline.at(guessIndex);\n      // TODO put this logic in \"isClueBetweenDates\"\n      let beforeGuess = (guessIndex > 0) ? timeline.at(guessIndex - 1) : null;\n\n      if (isClueBetweenDates(clue, guess, beforeGuess)) {\n        console.log(\"Correct: ++Score\");\n        clue.flash = false;\n        setGame(prevGame => prevGame.copyWithNextClue().incrementScore());\n      } else {\n        console.log(\"Incorrect: --Score\");\n        clue.flash = true;\n        // TODO apparently clue is not a Clue instance at this point?\n        setGame(prevGame => new Game({ \n          clues: clues, \n          timeline: prevGame.timeline.resetMargins(),\n          ...prevGame }));\n        setGame(prevGame => prevGame.decrementScore());\n      }\n    } else {\n      console.log(\"No card found at drop location\");\n    }\n  }\n\n  let dragDropInterface = {\n    onDrop: dropHandler,\n    onDragOver: dragoverHandler,\n    onDragLeave: dragleaveHandler\n  } \n\n  const timelineWidth = {\n    style: { width: \n      `calc(${timeline.length} * (var(--card-width) + var(--card-margin)) + 4 * var(--card-margin)`\n    }\n  }\n  const windowWidth = document.documentElement.clientWidth;\n  const ruleWidth = (timelineWidth > windowWidth) ? timelineWidth : null;\n\n  if (game.isActive) {\n    return(\n      <div className=\"scrollingTimeline\">\n        <hr />\n        <div className=\"timelineBar\" {...timelineWidth} >\n          <hr {...ruleWidth} />\n          <div className=\"timeline\" {...dragDropInterface}>\n            {timeline.map(card => <Card key={card.id}>{card}</Card>)}\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}