{"ast":null,"code":"export default class Timeline {\n  constructor({\n    title = \"\",\n    description = \"\",\n    keywords = [],\n    creator = \"\",\n    facts = []\n  } = {}) {\n    this.title = void 0;\n    this.description = void 0;\n    this.keywords = void 0;\n    this.creator = void 0;\n    this.facts = void 0;\n    this.title = title;\n    this.description = description;\n    this.keywords = keywords;\n    this.creator = creator;\n    this.facts = facts;\n  }\n  static parseKeywords(inputStr = \"\") {\n    if (inputStr) {\n      return inputStr.split(\";\").map(s => s.trim());\n    } else {\n      return [];\n    }\n  }\n  get keywordString() {\n    return this.keywords.join(\"; \");\n  }\n  static newFromKeywordString({\n    title,\n    description,\n    keywords,\n    creator,\n    facts\n  }) {\n    return new Timeline({\n      title: title,\n      description: description,\n      keywords: keywords ? Timeline.parseKeywords(keywords) : [],\n      creator: creator,\n      facts: facts\n    });\n  }\n  json() {\n    return JSON.stringify({\n      title: this.title,\n      description: this.description,\n      keywords: this.keywordString,\n      creator: this.creator,\n      facts: this.facts.map(e => e.json())\n    });\n  }\n  sortByDate() {\n    this.facts.sort((c1, c2) => c1.date - c2.date);\n    return this;\n  }\n  removeFact(fact) {\n    let filtered = this.facts.filter(f => f !== fact);\n    return new Timeline({\n      ...this,\n      facts: filtered\n    });\n  }\n}","map":{"version":3,"names":["Timeline","constructor","title","description","keywords","creator","facts","parseKeywords","inputStr","split","map","s","trim","keywordString","join","newFromKeywordString","json","JSON","stringify","e","sortByDate","sort","c1","c2","date","removeFact","fact","filtered","filter","f"],"sources":["/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/src/classes/Timeline.tsx"],"sourcesContent":["interface TimelineInput {\n  title: string;\n  description: string;\n  keywords: Array<string>;\n  creator: string;\n  facts: FactList;\n}\n\nexport default class Timeline {\n  title: string;\n  description: string;\n  keywords: Array<string>;\n  creator: string;\n  facts: Array<Fact>;\n\n  constructor({ \n    title = \"\", \n    description = \"\", \n    keywords = [], \n    creator = \"\", \n    facts = []\n  }: TimelineInput = {}) {\n    this.title = title;\n    this.description = description;\n    this.keywords = keywords;\n    this.creator = creator;\n    this.facts = facts;\n  }\n\n  static parseKeywords(inputStr: string = \"\"): Array<string> {\n    if (inputStr) {\n      return inputStr.split(\";\").map(s => s.trim());\n    } else {\n      return [];\n    }\n  }\n\n  get keywordString() {\n    return this.keywords.join(\"; \");\n  }\n\n  static newFromKeywordString({ title, description, keywords, creator, facts }) {\n    return new Timeline({\n      title: title,\n      description: description,\n      keywords: keywords ? Timeline.parseKeywords(keywords) : [],\n      creator: creator,\n      facts: facts\n    });\n  }\n\n  json() {\n    return JSON.stringify({\n      title: this.title,\n      description: this.description,\n      keywords: this.keywordString,\n      creator: this.creator,\n      facts: this.facts.map(e => e.json())\n     });\n  }\n\n  sortByDate() {\n    this.facts.sort((c1, c2) => c1.date - c2.date);\n    return this;\n  }\n\n  removeFact(fact) {\n    let filtered = this.facts.filter(f => f !== fact);\n    return new Timeline({\n      ...this,\n      facts: filtered\n    });\n  }\n}\n\n\n"],"mappings":"AAQA,eAAe,MAAMA,QAAQ,CAAC;EAO5BC,WAAWA,CAAC;IACVC,KAAK,GAAG,EAAE;IACVC,WAAW,GAAG,EAAE;IAChBC,QAAQ,GAAG,EAAE;IACbC,OAAO,GAAG,EAAE;IACZC,KAAK,GAAG;EACK,CAAC,GAAG,CAAC,CAAC,EAAE;IAAA,KAZvBJ,KAAK;IAAA,KACLC,WAAW;IAAA,KACXC,QAAQ;IAAA,KACRC,OAAO;IAAA,KACPC,KAAK;IASH,IAAI,CAACJ,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,KAAK,GAAGA,KAAK;EACpB;EAEA,OAAOC,aAAaA,CAACC,QAAgB,GAAG,EAAE,EAAiB;IACzD,IAAIA,QAAQ,EAAE;MACZ,OAAOA,QAAQ,CAACC,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACC,IAAI,CAAC,CAAC,CAAC;IAC/C,CAAC,MAAM;MACL,OAAO,EAAE;IACX;EACF;EAEA,IAAIC,aAAaA,CAAA,EAAG;IAClB,OAAO,IAAI,CAACT,QAAQ,CAACU,IAAI,CAAC,IAAI,CAAC;EACjC;EAEA,OAAOC,oBAAoBA,CAAC;IAAEb,KAAK;IAAEC,WAAW;IAAEC,QAAQ;IAAEC,OAAO;IAAEC;EAAM,CAAC,EAAE;IAC5E,OAAO,IAAIN,QAAQ,CAAC;MAClBE,KAAK,EAAEA,KAAK;MACZC,WAAW,EAAEA,WAAW;MACxBC,QAAQ,EAAEA,QAAQ,GAAGJ,QAAQ,CAACO,aAAa,CAACH,QAAQ,CAAC,GAAG,EAAE;MAC1DC,OAAO,EAAEA,OAAO;MAChBC,KAAK,EAAEA;IACT,CAAC,CAAC;EACJ;EAEAU,IAAIA,CAAA,EAAG;IACL,OAAOC,IAAI,CAACC,SAAS,CAAC;MACpBhB,KAAK,EAAE,IAAI,CAACA,KAAK;MACjBC,WAAW,EAAE,IAAI,CAACA,WAAW;MAC7BC,QAAQ,EAAE,IAAI,CAACS,aAAa;MAC5BR,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBC,KAAK,EAAE,IAAI,CAACA,KAAK,CAACI,GAAG,CAACS,CAAC,IAAIA,CAAC,CAACH,IAAI,CAAC,CAAC;IACpC,CAAC,CAAC;EACL;EAEAI,UAAUA,CAAA,EAAG;IACX,IAAI,CAACd,KAAK,CAACe,IAAI,CAAC,CAACC,EAAE,EAAEC,EAAE,KAAKD,EAAE,CAACE,IAAI,GAAGD,EAAE,CAACC,IAAI,CAAC;IAC9C,OAAO,IAAI;EACb;EAEAC,UAAUA,CAACC,IAAI,EAAE;IACf,IAAIC,QAAQ,GAAG,IAAI,CAACrB,KAAK,CAACsB,MAAM,CAACC,CAAC,IAAIA,CAAC,KAAKH,IAAI,CAAC;IACjD,OAAO,IAAI1B,QAAQ,CAAC;MAClB,GAAG,IAAI;MACPM,KAAK,EAAEqB;IACT,CAAC,CAAC;EACJ;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}