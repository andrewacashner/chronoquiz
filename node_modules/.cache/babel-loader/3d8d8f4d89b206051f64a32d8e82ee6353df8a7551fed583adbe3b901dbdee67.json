{"ast":null,"code":"import _classPrivateFieldLooseBase from \"/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";\nimport _classPrivateFieldLooseKey from \"/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";\nvar _TimelineDeck;\nimport FactCard from \"./FactCard\";\nimport { default as Color } from \"./RgbColorMix\";\nvar _items = /*#__PURE__*/_classPrivateFieldLooseKey(\"items\");\nvar _setColors = /*#__PURE__*/_classPrivateFieldLooseKey(\"setColors\");\nvar _shuffle = /*#__PURE__*/_classPrivateFieldLooseKey(\"shuffle\");\nexport default class TimelineDeck {\n  constructor(cards = []) {\n    // Shuffle the array, using the Fisher-Yates/Knuth shuffle\n    // (`https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle`)\n    Object.defineProperty(this, _shuffle, {\n      value: _shuffle2\n    });\n    // PRIVATE METHODS\n    // Set the colors of the cards in this list, in chronological order, to\n    // evenly spaced intervals along the spectrum.\n    Object.defineProperty(this, _setColors, {\n      value: _setColors2\n    });\n    Object.defineProperty(this, _items, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldLooseBase(this, _items)[_items] = cards;\n  }\n  get cards() {\n    return _classPrivateFieldLooseBase(this, _items)[_items];\n  }\n  json() {\n    return _classPrivateFieldLooseBase(this, _items)[_items].map(i => i.json());\n  }\n  // PUBLIC METHODS\n\n  clone() {\n    return new TimelineDeck([..._classPrivateFieldLooseBase(this, _items)[_items]]);\n  }\n\n  // Sort the array by the date field, ascending.\n  sortByDate() {\n    _classPrivateFieldLooseBase(this, _items)[_items].sort((c1, c2) => {\n      return c1.fact.date - c2.fact.date;\n    });\n    return this;\n  }\n  sortedByDate() {\n    return this.clone().sortByDate();\n  }\n  setupClues() {\n    _classPrivateFieldLooseBase(this, _setColors)[_setColors]();\n    _classPrivateFieldLooseBase(this, _shuffle)[_shuffle]();\n  }\n  get length() {\n    return _classPrivateFieldLooseBase(this, _items)[_items].length;\n  }\n  isEmpty() {\n    return this.length === 0;\n  }\n  allButLastItems() {\n    return _classPrivateFieldLooseBase(this, _items)[_items].slice(0, -1);\n  }\n  last() {\n    return _classPrivateFieldLooseBase(this, _items)[_items].at(-1);\n  }\n  pop() {\n    let card = _classPrivateFieldLooseBase(this, _items)[_items].pop();\n    return card;\n  }\n  dropLast() {\n    this.pop();\n    return this;\n  }\n  dropLastCopy() {\n    return new TimelineDeck(_classPrivateFieldLooseBase(this, _items)[_items].slice(0, -1));\n  }\n  prepend(item) {\n    _classPrivateFieldLooseBase(this, _items)[_items].unshift(item);\n    return this;\n  }\n  prependCopy(item) {\n    return new TimelineDeck([item, ..._classPrivateFieldLooseBase(this, _items)[_items]]);\n  }\n\n  // Add event to array and then resort by date.\n  addFact(card) {\n    _classPrivateFieldLooseBase(this, _items)[_items].push(card);\n    this.sortByDate();\n    return this;\n  }\n  resetMargins() {\n    let resetItems = [];\n    for (let i of _classPrivateFieldLooseBase(this, _items)[_items]) {\n      let card = new FactCard({\n        ...i,\n        expand: false\n      });\n      resetItems.push(card);\n    }\n    return new TimelineDeck(resetItems);\n  }\n  addAnswer(answer) {\n    return this.prependCopy(answer).sortedByDate().resetMargins();\n  }\n  findById(id) {\n    return _classPrivateFieldLooseBase(this, _items)[_items].find(c => c.id === id);\n  }\n  findIndexById(id) {\n    return _classPrivateFieldLooseBase(this, _items)[_items].findIndex(c => c.id === id);\n  }\n  at(index) {\n    return _classPrivateFieldLooseBase(this, _items)[_items].at(index);\n  }\n  map(fn) {\n    return _classPrivateFieldLooseBase(this, _items)[_items].map(fn);\n  }\n  appendClone(newCard) {\n    return this.clone().addFact(newCard);\n  }\n}\n_TimelineDeck = TimelineDeck;\nfunction _setColors2() {\n  this.sortByDate();\n  let items = _classPrivateFieldLooseBase(this, _items)[_items];\n  items.forEach((card, index) => {\n    items[index].color = Color.colorAtIndex(index, items.length, Color.SPECTRUM);\n  });\n  return this;\n}\nfunction _shuffle2() {\n  function randomInt(max) {\n    return Math.floor(Math.random() * max);\n  }\n  let items = _classPrivateFieldLooseBase(this, _items)[_items];\n  for (let i = items.length - 1; i > 0; --i) {\n    let j = randomInt(i);\n    [items[i], items[j]] = [items[j], items[i]];\n  }\n  return this;\n}","map":{"version":3,"names":["FactCard","default","Color","_items","_classPrivateFieldLooseKey","_setColors","_shuffle","TimelineDeck","constructor","cards","Object","defineProperty","value","_shuffle2","_setColors2","writable","_classPrivateFieldLooseBase","json","map","i","clone","sortByDate","sort","c1","c2","fact","date","sortedByDate","setupClues","length","isEmpty","allButLastItems","slice","last","at","pop","card","dropLast","dropLastCopy","prepend","item","unshift","prependCopy","addFact","push","resetMargins","resetItems","expand","addAnswer","answer","findById","id","find","c","findIndexById","findIndex","index","fn","appendClone","newCard","_TimelineDeck","items","forEach","color","colorAtIndex","SPECTRUM","randomInt","max","Math","floor","random","j"],"sources":["/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/src/classes/TimelineDeck.tsx"],"sourcesContent":["import FactCard from \"./FactCard\";\nimport { default as Color } from \"./RgbColorMix\";\n\nexport default class TimelineDeck {\n  #items: Array<FactCard>;\n\n  constructor(cards: Array<FactCard> = []) {\n    this.#items = cards;\n  }\n\n  get cards() {\n    return this.#items;\n  }\n\n  json() {\n    return this.#items.map(i => i.json());\n  }\n\n  // PRIVATE METHODS\n  \n  // Set the colors of the cards in this list, in chronological order, to\n  // evenly spaced intervals along the spectrum.\n  #setColors(): TimelineDeck {\n    this.sortByDate();\n    let items = this.#items;\n\n    items.forEach((card, index) => {\n      items[index].color = Color.colorAtIndex(index, items.length, \n                                              Color.SPECTRUM);\n    });\n    return this;\n  } \n\n  // Shuffle the array, using the Fisher-Yates/Knuth shuffle\n  // (`https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle`)\n  #shuffle(): TimelineDeck {\n    \n    function randomInt(max: number): number {\n      return Math.floor(Math.random() * max);\n    } \n\n    let items = this.#items;\n\n    for (let i = items.length - 1; i > 0; --i) {\n      let j = randomInt(i);\n      [items[i], items[j]] = [items[j], items[i]];\n    }\n\n    return this;\n  }\n\n  // PUBLIC METHODS\n\n  clone(): TimelineDeck {\n    return new TimelineDeck([...this.#items]);\n  }\n\n  // Sort the array by the date field, ascending.\n  sortByDate(): TimelineDeck {\n    this.#items.sort((c1, c2) => { return c1.fact.date - c2.fact.date });\n    return this;\n  }\n\n  sortedByDate(): TimelineDeck {\n    return this.clone().sortByDate();\n  }\n  \n\n  setupClues() {\n    this.#setColors();\n    this.#shuffle();\n  }\n\n  get length(): number {\n    return this.#items.length;\n  }\n\n  isEmpty(): boolean {\n    return this.length === 0;\n  }\n\n  allButLastItems(): Array<FactCard> {\n    return this.#items.slice(0, -1);\n  }\n\n  last(): FactCard {\n    return this.#items.at(-1);\n  }\n\n  pop(): FactCard {\n    let card = this.#items.pop();\n    return card;\n  }\n\n  dropLast(): TimelineDeck {\n    this.pop();\n    return this;\n  }\n\n  dropLastCopy(): TimelineDeck {\n    return new TimelineDeck(this.#items.slice(0, -1));\n  }\n\n  prepend(item): TimelineDeck {\n    this.#items.unshift(item);\n    return this;\n  }\n  \n  prependCopy(item): TimelineDeck {\n    return new TimelineDeck([item, ...this.#items]);\n  }\n\n  // Add event to array and then resort by date.\n  addFact(card) {\n    this.#items.push(card);\n    this.sortByDate();\n    return this;\n  }\n\n  resetMargins(): TimelineDeck {\n    let resetItems = [];\n    for (let i of this.#items) {\n      let card = new FactCard({...i, expand: false});\n      resetItems.push(card);\n    }\n    return new TimelineDeck(resetItems);\n  }\n\n  addAnswer(answer): TimelineDeck {\n    return this.prependCopy(answer).sortedByDate().resetMargins();\n  }\n\n  findById(id: string): FactCard {\n    return this.#items.find(c => c.id === id);\n  }\n\n  findIndexById(id: string): FactCard {\n    return this.#items.findIndex(c => c.id === id);\n  }\n\n  at(index: number): FactCard {\n    return this.#items.at(index);\n  }\n\n  map(fn: (FactCard) => FactCard): TimelineDeck {\n    return this.#items.map(fn);\n  }\n\n  appendClone(newCard: FactCard): TimelineDeck {\n    return this.clone().addFact(newCard);\n  }\n\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}