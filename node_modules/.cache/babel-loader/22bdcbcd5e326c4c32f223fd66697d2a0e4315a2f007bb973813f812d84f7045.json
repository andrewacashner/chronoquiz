{"ast":null,"code":"var _jsxFileName = \"/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/src/components/Timeline.tsx\",\n  _s = $RefreshSig$();\nimport { useContext } from \"react\";\nimport TimelineContext from \"../store/TimelineContext\";\nimport Card from \"./Card\";\n\n// /** \n//  * Return a card element, if found at given coordinates; or null. \n//  * @param {number} x - horizontal coordinate\n//  * @param {number} y - vertical coordinate\n//  * @returns {element} - DOM div.card element at (x,y), if there is one\n//  */\n// function cardAtCoord(x, y) {\n//   let el = document.elementFromPoint(x, y);\n//   return isCard(el) ? el : null;\n// }\n// \n/** Get the center point between two coordinates.\n * @param {number} a - smaller coordinate (left edge) \n * @param {number} b - larger coordinate (right edge)\n * @returns {number}\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction midpoint(a, b) {\n  return (b - a) / 2 + a;\n}\n\n// function isCardElement(el: HTMLElement): boolean {\n//   return el.className === \"card\";\n// }\n\nexport default function Clues() {\n  _s();\n  let context = useContext(TimelineContext);\n  let [game, setGame] = [context.get, context.set];\n  let timeline = game.timeline;\n\n  // Allow to move by dragging. Insert gap to the left of a card when the drag\n  // point is in range to guess this card.\n  function dragoverHandler(event) {\n    event.preventDefault();\n    let bounds = event.target.getBoundingClientRect();\n    let center = midpoint(bounds.left, bounds.right);\n    if (event.clientX <= center) {\n      console.log(\"In range\");\n      let cardUnderDrag = cardAtCoord(event.clientX, event.clientY);\n      if (cardUnderDrag) {\n        let match = cards.find(c => c.id === cardUnderDrag.id);\n        match.expand = true;\n      }\n    }\n    event.dataTransfer.effectAllowed = \"move\";\n  }\n\n  //  function dragleaveHandler(event: React.DragEvent<HTMLElement>): void {\n  //    let el = event.target;\n  //    if (isCardElement(el)) {\n  //      restoreMargin();\n  //    }\n  //  }\n\n  /**\n   * Procedure: When the user drops a card onto a timeline card, \n   * find the closest card, test if the date on the clue is between that card\n   * and its previous neighbor (if there is one); if so insert the card and\n   * increment the score; if not, do not insert the card and decrement the\n   * score.\n   */\n  function dropHandler(event) {\n    //    /**\n    //     * Is the given clue between a given answer card and the one before it?\n    //     * @param {element} clue - card node\n    //     * @param {element} guess - card node where clue was dropped\n    //     * @param {element} preGuess - previousSibling to guess (could be null)\n    //     * @returns {boolean}\n    //     */\n    //    function isClueBetweenDates(clue, guess, preGuess) {\n    //      let clueDate = clue.dataset.when;\n    //      let guessDate = guess.dataset.when;\n    //      let isBeforeGuess = clueDate <= guessDate;\n    //\n    //      let noPreGuess = !preGuess;\n    //      let isAfterPreGuess = preGuess && (clueDate >= preGuess.dataset.when);\n    //      let isAfterAnyPreGuess = noPreGuess || isAfterPreGuess;\n    //\n    //      return isBeforeGuess && isAfterAnyPreGuess;\n    //    }\n\n    event.preventDefault();\n    setGame(prevGame => prevGame.copyWithNextClue());\n\n    //    setGame(prevGame => prevGame.incrementScore());\n\n    // // Find nearest answer (first card found to right of click) to compare\n    // let clue = document.getElementById(event.dataTransfer.getData(\"id\"));\n    // let guess = findFirstCardToRight(event);\n\n    // if (guess) {\n    //   let beforeGuess = guess.previousElementSibling;\n\n    //   if (isClueBetweenDates(clue, guess, beforeGuess)) {\n    //     console.log(\"Correct: ++Score\");\n\n    //     state.incrementScore();\n    //     state.nextClue();\n    //     updateDisplay(state);\n    //   } else {\n    //     console.log(\"Incorrect, --Score\");\n    //     flashAlert(clue);\n\n    //     state.decrementScore();\n    //     updateDisplay(state);\n    //   }\n    // } else {\n    //   console.log(\"No card found at drop location\");\n    // }\n  }\n  let dragDropInterface = {\n    onDrop: dropHandler,\n    onDragOver: dragoverHandler\n    //    onDragLeave: dragleaveHandler\n  };\n  if (game.isActive && timeline && !(timeline !== null && timeline !== void 0 && timeline.isEmpty())) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"timeline\",\n      ...dragDropInterface,\n      children: timeline.items.map(card => /*#__PURE__*/_jsxDEV(Card, {\n        children: card\n      }, card.id, false, {\n        fileName: _jsxFileName,\n        lineNumber: 128,\n        columnNumber: 37\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 127,\n      columnNumber: 7\n    }, this);\n  }\n}\n_s(Clues, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n_c = Clues;\nvar _c;\n$RefreshReg$(_c, \"Clues\");","map":{"version":3,"names":["useContext","TimelineContext","Card","jsxDEV","_jsxDEV","midpoint","a","b","Clues","_s","context","game","setGame","get","set","timeline","dragoverHandler","event","preventDefault","bounds","target","getBoundingClientRect","center","left","right","clientX","console","log","cardUnderDrag","cardAtCoord","clientY","match","cards","find","c","id","expand","dataTransfer","effectAllowed","dropHandler","prevGame","copyWithNextClue","dragDropInterface","onDrop","onDragOver","isActive","isEmpty","className","children","items","map","card","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/src/components/Timeline.tsx"],"sourcesContent":["import { useContext } from \"react\";\nimport TimelineContext from \"../store/TimelineContext\";\n\nimport Card from \"./Card\";\n\n// /** \n//  * Return a card element, if found at given coordinates; or null. \n//  * @param {number} x - horizontal coordinate\n//  * @param {number} y - vertical coordinate\n//  * @returns {element} - DOM div.card element at (x,y), if there is one\n//  */\n// function cardAtCoord(x, y) {\n//   let el = document.elementFromPoint(x, y);\n//   return isCard(el) ? el : null;\n// }\n// \n /** Get the center point between two coordinates.\n  * @param {number} a - smaller coordinate (left edge) \n  * @param {number} b - larger coordinate (right edge)\n  * @returns {number}\n  */\n function midpoint(a, b) {\n   return (b - a) / 2 + a;\n }\n \n// function isCardElement(el: HTMLElement): boolean {\n//   return el.className === \"card\";\n// }\n\n\nexport default function Clues() {\n  let context = useContext(TimelineContext);\n  let [game, setGame] = [context.get, context.set];\n  let timeline = game.timeline;\n\n  // Allow to move by dragging. Insert gap to the left of a card when the drag\n  // point is in range to guess this card.\n  function dragoverHandler(event) {\n    event.preventDefault();\n  \n    let bounds = event.target.getBoundingClientRect();\n    let center = midpoint(bounds.left, bounds.right);\n  \n    if (event.clientX <= center) {\n      console.log(\"In range\");\n      let cardUnderDrag = cardAtCoord(event.clientX, event.clientY);\n      if (cardUnderDrag) {\n        let match = cards.find(c => c.id === cardUnderDrag.id);\n        match.expand = true;\n      }\n    }\n    event.dataTransfer.effectAllowed = \"move\";\n  }\n  \n  //  function dragleaveHandler(event: React.DragEvent<HTMLElement>): void {\n  //    let el = event.target;\n  //    if (isCardElement(el)) {\n  //      restoreMargin();\n  //    }\n  //  }\n\n  /**\n   * Procedure: When the user drops a card onto a timeline card, \n   * find the closest card, test if the date on the clue is between that card\n   * and its previous neighbor (if there is one); if so insert the card and\n   * increment the score; if not, do not insert the card and decrement the\n   * score.\n   */\n  function dropHandler(event) {\n    //    /**\n    //     * Is the given clue between a given answer card and the one before it?\n    //     * @param {element} clue - card node\n    //     * @param {element} guess - card node where clue was dropped\n    //     * @param {element} preGuess - previousSibling to guess (could be null)\n    //     * @returns {boolean}\n    //     */\n    //    function isClueBetweenDates(clue, guess, preGuess) {\n    //      let clueDate = clue.dataset.when;\n    //      let guessDate = guess.dataset.when;\n    //      let isBeforeGuess = clueDate <= guessDate;\n    //\n    //      let noPreGuess = !preGuess;\n    //      let isAfterPreGuess = preGuess && (clueDate >= preGuess.dataset.when);\n    //      let isAfterAnyPreGuess = noPreGuess || isAfterPreGuess;\n    //\n    //      return isBeforeGuess && isAfterAnyPreGuess;\n    //    }\n\n    event.preventDefault();\n    setGame(prevGame => prevGame.copyWithNextClue());\n\n    //    setGame(prevGame => prevGame.incrementScore());\n\n    // // Find nearest answer (first card found to right of click) to compare\n    // let clue = document.getElementById(event.dataTransfer.getData(\"id\"));\n    // let guess = findFirstCardToRight(event);\n\n    // if (guess) {\n    //   let beforeGuess = guess.previousElementSibling;\n\n    //   if (isClueBetweenDates(clue, guess, beforeGuess)) {\n    //     console.log(\"Correct: ++Score\");\n\n    //     state.incrementScore();\n    //     state.nextClue();\n    //     updateDisplay(state);\n    //   } else {\n    //     console.log(\"Incorrect, --Score\");\n    //     flashAlert(clue);\n\n    //     state.decrementScore();\n    //     updateDisplay(state);\n    //   }\n    // } else {\n    //   console.log(\"No card found at drop location\");\n    // }\n  }\n\n  let dragDropInterface = {\n    onDrop: dropHandler,\n    onDragOver: dragoverHandler,\n    //    onDragLeave: dragleaveHandler\n  } \n\n  if (game.isActive && timeline && !timeline?.isEmpty()) {\n    return(\n      <div className=\"timeline\" {...dragDropInterface}>\n        {timeline.items.map(card => <Card key={card.id}>{card}</Card>)}\n      </div>\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}