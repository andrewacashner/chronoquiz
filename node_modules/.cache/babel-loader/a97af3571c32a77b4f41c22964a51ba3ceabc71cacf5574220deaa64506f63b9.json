{"ast":null,"code":"var _jsxFileName = \"/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/src/components/Timeline.tsx\",\n  _s = $RefreshSig$();\nimport { useContext } from \"react\";\nimport TimelineContext from \"../store/TimelineContext\";\nimport Card from \"./Card\";\n\n// /** CSS value for card's normal left margin when shifted right */\n// const CARD_LEFT_MARGIN_DEFAULT = \"var(--card-margin)\";\n// const CARD_LEFT_MARGIN_EXTRA = `calc(5 * ${CARD_LEFT_MARGIN_DEFAULT})`;\n\n/** \n * Return a card element, if found at given coordinates; or null. \n * @param {number} x - horizontal coordinate\n * @param {number} y - vertical coordinate\n * @returns {element} - DOM div.card element at (x,y), if there is one\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction cardAtCoord(x, y) {\n  let el = document.elementFromPoint(x, y);\n  return isCard(el) ? el : null;\n}\n\n/** Get the center point between two coordinates.\n * @param {number} a - smaller coordinate (left edge) \n * @param {number} b - larger coordinate (right edge)\n * @returns {number}\n */\nfunction midpoint(a, b) {\n  return (b - a) / 2 + a;\n}\nfunction isCardElement(el) {\n  return el.className === \"card\";\n}\nexport default function Clues() {\n  _s();\n  let context = useContext(TimelineContext);\n  let game = context.get;\n  let timeline = game.timeline;\n\n  //  let [lmargin, setLmargin] = useState(CARD_LEFT_MARGIN_DEFAULT);\n  //\n  //  const expandMargin = () => setLmargin(CARD_LEFT_MARGIN_EXTRA);\n  //  const restoreMargin = () => setLmargin(CARD_LEFT_MARGIN_DEFAULT);\n  //\n  //  // Allow to move by dragging. Insert gap to the left of a card when the drag\n  //  // point is in range to guess this card.\n  //  function dragoverHandler(event) {\n  //    event.preventDefault();\n  //\n  //    let bounds = event.target.getBoundingClientRect();\n  //    let center = midpoint(bounds.left, bounds.right);\n  //\n  //    if (event.clientX <= center) {\n  //      console.log(\"In range\");\n  //      let cardUnderDrag = cardAtCoord(event.clientX, event.clientY);\n  //      if (cardUnderDrag) {\n  //        expandMargin();\n  //      }\n  //    }\n  //    event.dataTransfer.effectAllowed = \"move\";\n  //  }\n  //\n  //  function dragleaveHandler(event: React.DragEvent<HTMLElement>): void {\n  //    let el = event.target;\n  //    if (isCardElement(el)) {\n  //      restoreMargin();\n  //    }\n  //  }\n\n  /**\n   * Procedure: When the user drops a card onto a timeline card, \n   * find the closest card, test if the date on the clue is between that card\n   * and its previous neighbor (if there is one); if so insert the card and\n   * increment the score; if not, do not insert the card and decrement the\n   * score.\n   * @param {event} event\n   */\n  function dropHandler(event) {\n    /**\n     * Is the given clue between a given answer card and the one before it?\n     * @param {element} clue - card node\n     * @param {element} guess - card node where clue was dropped\n     * @param {element} preGuess - previousSibling to guess (could be null)\n     * @returns {boolean}\n     */\n    function isClueBetweenDates(clue, guess, preGuess) {\n      let clueDate = clue.dataset.when;\n      let guessDate = guess.dataset.when;\n      let isBeforeGuess = clueDate <= guessDate;\n      let noPreGuess = !preGuess;\n      let isAfterPreGuess = preGuess && clueDate >= preGuess.dataset.when;\n      let isAfterAnyPreGuess = noPreGuess || isAfterPreGuess;\n      return isBeforeGuess && isAfterAnyPreGuess;\n    }\n    event.preventDefault();\n    setGame(prevGame => prevGame.incrementScore());\n    game.nextClue();\n\n    // // Find nearest answer (first card found to right of click) to compare\n    // let clue = document.getElementById(event.dataTransfer.getData(\"id\"));\n    // let guess = findFirstCardToRight(event);\n\n    // if (guess) {\n    //   let beforeGuess = guess.previousElementSibling;\n\n    //   if (isClueBetweenDates(clue, guess, beforeGuess)) {\n    //     console.log(\"Correct: ++Score\");\n\n    //     state.incrementScore();\n    //     state.nextClue();\n    //     updateDisplay(state);\n    //   } else {\n    //     console.log(\"Incorrect, --Score\");\n    //     flashAlert(clue);\n\n    //     state.decrementScore();\n    //     updateDisplay(state);\n    //   }\n    // } else {\n    //   console.log(\"No card found at drop location\");\n    // }\n  }\n  let dragDropInterface = {\n    onDrop: dropHandler\n    //    onDragOver: dragoverHandler,\n    //    onDragLeave: dragleaveHandler\n  };\n  if (game.isActive && timeline && !(timeline !== null && timeline !== void 0 && timeline.isEmpty())) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"timeline\",\n      ...dragDropInterface,\n      children: timeline.items.map(card => /*#__PURE__*/_jsxDEV(Card, {\n        children: card\n      }, card.id, false, {\n        fileName: _jsxFileName,\n        lineNumber: 134,\n        columnNumber: 37\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 133,\n      columnNumber: 7\n    }, this);\n  }\n}\n_s(Clues, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n_c = Clues;\nvar _c;\n$RefreshReg$(_c, \"Clues\");","map":{"version":3,"names":["useContext","TimelineContext","Card","jsxDEV","_jsxDEV","cardAtCoord","x","y","el","document","elementFromPoint","isCard","midpoint","a","b","isCardElement","className","Clues","_s","context","game","get","timeline","dropHandler","event","isClueBetweenDates","clue","guess","preGuess","clueDate","dataset","when","guessDate","isBeforeGuess","noPreGuess","isAfterPreGuess","isAfterAnyPreGuess","preventDefault","setGame","prevGame","incrementScore","nextClue","dragDropInterface","onDrop","isActive","isEmpty","children","items","map","card","id","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/src/components/Timeline.tsx"],"sourcesContent":["import { useContext } from \"react\";\nimport TimelineContext from \"../store/TimelineContext\";\nimport Card from \"./Card\";\n\n// /** CSS value for card's normal left margin when shifted right */\n// const CARD_LEFT_MARGIN_DEFAULT = \"var(--card-margin)\";\n// const CARD_LEFT_MARGIN_EXTRA = `calc(5 * ${CARD_LEFT_MARGIN_DEFAULT})`;\n\n/** \n * Return a card element, if found at given coordinates; or null. \n * @param {number} x - horizontal coordinate\n * @param {number} y - vertical coordinate\n * @returns {element} - DOM div.card element at (x,y), if there is one\n */\nfunction cardAtCoord(x, y) {\n  let el = document.elementFromPoint(x, y);\n  return isCard(el) ? el : null;\n}\n\n/** Get the center point between two coordinates.\n * @param {number} a - smaller coordinate (left edge) \n * @param {number} b - larger coordinate (right edge)\n * @returns {number}\n */\nfunction midpoint(a, b) {\n  return (b - a) / 2 + a;\n}\n\nfunction isCardElement(el: HTMLElement): boolean {\n  return el.className === \"card\";\n}\n\n\nexport default function Clues() {\n  let context = useContext(TimelineContext);\n  let game = context.get;\n  let timeline = game.timeline;\n\n  //  let [lmargin, setLmargin] = useState(CARD_LEFT_MARGIN_DEFAULT);\n  //\n  //  const expandMargin = () => setLmargin(CARD_LEFT_MARGIN_EXTRA);\n  //  const restoreMargin = () => setLmargin(CARD_LEFT_MARGIN_DEFAULT);\n  //\n  //  // Allow to move by dragging. Insert gap to the left of a card when the drag\n  //  // point is in range to guess this card.\n  //  function dragoverHandler(event) {\n  //    event.preventDefault();\n  //\n  //    let bounds = event.target.getBoundingClientRect();\n  //    let center = midpoint(bounds.left, bounds.right);\n  //\n  //    if (event.clientX <= center) {\n  //      console.log(\"In range\");\n  //      let cardUnderDrag = cardAtCoord(event.clientX, event.clientY);\n  //      if (cardUnderDrag) {\n  //        expandMargin();\n  //      }\n  //    }\n  //    event.dataTransfer.effectAllowed = \"move\";\n  //  }\n  //\n  //  function dragleaveHandler(event: React.DragEvent<HTMLElement>): void {\n  //    let el = event.target;\n  //    if (isCardElement(el)) {\n  //      restoreMargin();\n  //    }\n  //  }\n\n  /**\n   * Procedure: When the user drops a card onto a timeline card, \n   * find the closest card, test if the date on the clue is between that card\n   * and its previous neighbor (if there is one); if so insert the card and\n   * increment the score; if not, do not insert the card and decrement the\n   * score.\n   * @param {event} event\n   */\n  function dropHandler(event) {\n    /**\n     * Is the given clue between a given answer card and the one before it?\n     * @param {element} clue - card node\n     * @param {element} guess - card node where clue was dropped\n     * @param {element} preGuess - previousSibling to guess (could be null)\n     * @returns {boolean}\n     */\n    function isClueBetweenDates(clue, guess, preGuess) {\n      let clueDate = clue.dataset.when;\n      let guessDate = guess.dataset.when;\n      let isBeforeGuess = clueDate <= guessDate;\n\n      let noPreGuess = !preGuess;\n      let isAfterPreGuess = preGuess && (clueDate >= preGuess.dataset.when);\n      let isAfterAnyPreGuess = noPreGuess || isAfterPreGuess;\n\n      return isBeforeGuess && isAfterAnyPreGuess;\n    }\n\n    event.preventDefault();\n    setGame(prevGame => prevGame.incrementScore());\n    game.nextClue();\n\n    // // Find nearest answer (first card found to right of click) to compare\n    // let clue = document.getElementById(event.dataTransfer.getData(\"id\"));\n    // let guess = findFirstCardToRight(event);\n\n    // if (guess) {\n    //   let beforeGuess = guess.previousElementSibling;\n\n    //   if (isClueBetweenDates(clue, guess, beforeGuess)) {\n    //     console.log(\"Correct: ++Score\");\n\n    //     state.incrementScore();\n    //     state.nextClue();\n    //     updateDisplay(state);\n    //   } else {\n    //     console.log(\"Incorrect, --Score\");\n    //     flashAlert(clue);\n\n    //     state.decrementScore();\n    //     updateDisplay(state);\n    //   }\n    // } else {\n    //   console.log(\"No card found at drop location\");\n    // }\n  }\n  let dragDropInterface = {\n    onDrop: dropHandler,\n    //    onDragOver: dragoverHandler,\n    //    onDragLeave: dragleaveHandler\n  } \n\n  if (game.isActive && timeline && !timeline?.isEmpty()) {\n    return(\n      <div className=\"timeline\" {...dragDropInterface}>\n        {timeline.items.map(card => <Card key={card.id}>{card}</Card>)}\n      </div>\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}