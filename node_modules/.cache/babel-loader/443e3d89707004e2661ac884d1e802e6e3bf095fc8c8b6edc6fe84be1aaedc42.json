{"ast":null,"code":"import _classPrivateFieldLooseBase from\"/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";import _classPrivateFieldLooseKey from\"/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";import Fact from\"./Fact\";var _safe=/*#__PURE__*/_classPrivateFieldLooseKey(\"safe\");var _sanitizeDate=/*#__PURE__*/_classPrivateFieldLooseKey(\"sanitizeDate\");var _sanitizeImg=/*#__PURE__*/_classPrivateFieldLooseKey(\"sanitizeImg\");export default class FactCard{// Has this card been sanitized?\n// Each card gets the given info and a random unique identifier.\nconstructor(_ref){let{isClue=true,fact=new Fact(),color=null,expand=false,flash=false}=_ref;this.isClue=void 0;this.id=void 0;this.fact=void 0;this.color=void 0;// CSS color to be used in timeline\nthis.expand=void 0;// Add margin because a card is being dragged over?\nthis.flash=void 0;// Should this card flash an alert? (For wrong guess)\nObject.defineProperty(this,_safe,{writable:true,value:void 0});this.isClue=isClue;this.id=crypto.randomUUID();this.fact=fact;this.color=color;this.expand=expand;this.flash=flash;_classPrivateFieldLooseBase(this,_safe)[_safe]=false;// Has this card been sanitized?\n}markSafe(){_classPrivateFieldLooseBase(this,_safe)[_safe]=true;return this;}// PUBLIC METHODS\nget isSafe(){return _classPrivateFieldLooseBase(this,_safe)[_safe];}/** Creat a new card with sanitized input.\n   * - The date must be an integer string <= the current year (including\n   *   negative numbers).\n   * - The info is converted to plain text using textContent.\n   * - The image, if present, is downloaded and cached.\n   *\n   * The parameters are the same as for new FactCard().\n   *\n   * Returns: FactCard with validated content (with safe property set to true), or\n   * null if the input was invalid.\n   */static async newSafeCard(_ref2){let{isClue,date,info,img}=_ref2;let card=null;try{let cleanDate=_classPrivateFieldLooseBase(FactCard,_sanitizeDate)[_sanitizeDate](date);let cleanInfo=info;let cleanImg=await _classPrivateFieldLooseBase(FactCard,_sanitizeImg)[_sanitizeImg](img).catch(console.error);// The date is the only dealbreaker. We just skip a bad image link.\nif(cleanDate){card=new FactCard({isClue:isClue,fact:new Fact({date:cleanDate,info:cleanInfo,img:cleanImg})});card.markSafe();return card;}else{throw new Error(\"Could not sanitize card input with date '\".concat(date,\"', info '\").concat(info,\"'\"));}}catch(e){console.error(e);}return card;}json(){return this.fact.json();}// PRIVATE METHODS\n// Sanitize input \n/**\n   * Return the year if positive or year BC if negative. (Deals with the year\n   * only.) \n   *\n   * Technically BC should be offset by one year but we told users to use\n   * negative numbers as years BC.\n   *\n   * Returns: Formatted string for year, with BC if the year was\n   * negative\n   */dateToString(){if(this.isClue){return\"Clue\";}else{let yearZero=new Date();yearZero.setFullYear(0);let displayYear=this.fact.year;if(this.fact.date<yearZero){displayYear=\"\".concat(-displayYear,\" bce\");}return displayYear;}}// Return the date as YYYY year string.\nget year(){return this.fact.year;}copyAsAnswer(){return new FactCard({...this,isClue:false});}flash(){this.flash=true;return this;}}function _sanitizeDate2(rawDate){let date=null;try{let numTest=Number(rawDate);if(!isNaN(numTest)&&Number.isInteger(numTest)&&numTest<=new Date().getFullYear()){// TODO date comparison bad for cards with current year, because\n// they include exact time if created after Now card?\ndate=new Date();date.setFullYear(numTest);}else{throw new Error(\"Bad date input \".concat(rawDate));}}catch(e){console.error(e);}return date;}async function _sanitizeImg2(url){function getImageIfExists(url){return new Promise((resolve,reject)=>{const img=new Image();img.src=url;img.onload=()=>resolve(true);img.onerror=()=>resolve(false);});}let testedUrl=null;try{if(url){let imgTest=await getImageIfExists(url).catch(console.log);if(imgTest===true){testedUrl=url;}else{throw new Error(\"Image not found at url '\".concat(url,\"'\"));}}}catch(e){console.error(e);}return testedUrl;}Object.defineProperty(FactCard,_sanitizeImg,{value:_sanitizeImg2});Object.defineProperty(FactCard,_sanitizeDate,{value:_sanitizeDate2});","map":{"version":3,"names":["Fact","_safe","_classPrivateFieldLooseKey","_sanitizeDate","_sanitizeImg","FactCard","constructor","_ref","isClue","fact","color","expand","flash","id","Object","defineProperty","writable","value","crypto","randomUUID","_classPrivateFieldLooseBase","markSafe","isSafe","newSafeCard","_ref2","date","info","img","card","cleanDate","cleanInfo","cleanImg","catch","console","error","Error","concat","e","json","dateToString","yearZero","Date","setFullYear","displayYear","year","copyAsAnswer","_sanitizeDate2","rawDate","numTest","Number","isNaN","isInteger","getFullYear","_sanitizeImg2","url","getImageIfExists","Promise","resolve","reject","Image","src","onload","onerror","testedUrl","imgTest","log"],"sources":["/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/src/classes/FactCard.tsx"],"sourcesContent":["import Fact from \"./Fact\";\n\ninterface FactCardInput  {\n  isClue: boolean;      // Is this a clue (true) or answer?\n  fact: Fact;\n}\n\nexport default class FactCard {\n  isClue: boolean;\n  id: string;\n  fact: Fact;\n  color: string;    // CSS color to be used in timeline\n  expand: boolean;  // Add margin because a card is being dragged over?\n  flash: boolean;   // Should this card flash an alert? (For wrong guess)\n  #safe: boolean;   // Has this card been sanitized?\n\n  // Each card gets the given info and a random unique identifier.\n  constructor({ isClue = true, fact = new Fact(), color = null, expand = false, flash = false }: FactCardInput) {\n    this.isClue = isClue;\n    this.id = crypto.randomUUID();\n    this.fact = fact;\n    this.color = color;\n    this.expand = expand;\n    this.flash = flash;\n    this.#safe = false; // Has this card been sanitized?\n  }\n\n  markSafe(): FactCard {\n    this.#safe = true;\n    return this;\n  }\n\n  // PUBLIC METHODS\n\n  get isSafe(): boolean {\n    return this.#safe;\n  }\n\n  /** Creat a new card with sanitized input.\n   * - The date must be an integer string <= the current year (including\n   *   negative numbers).\n   * - The info is converted to plain text using textContent.\n   * - The image, if present, is downloaded and cached.\n   *\n   * The parameters are the same as for new FactCard().\n   *\n   * Returns: FactCard with validated content (with safe property set to true), or\n   * null if the input was invalid.\n   */\n  static async newSafeCard({ isClue, date, info, img }: \n                           FactCardInput): FactCard | null {\n    let card = null;\n    try {\n      let cleanDate = FactCard.#sanitizeDate(date);\n      let cleanInfo = info;\n      let cleanImg = await FactCard.#sanitizeImg(img).catch(console.error);\n\n      // The date is the only dealbreaker. We just skip a bad image link.\n      if (cleanDate) {\n        card = new FactCard({\n          isClue: isClue, \n          fact: new Fact({ date: cleanDate, info: cleanInfo, img: cleanImg})\n        });\n        card.markSafe();\n        return card;\n      } else {\n        throw new Error(`Could not sanitize card input with date '${date}', info '${info}'`);\n      }\n    } catch(e) {\n      console.error(e);\n    }\n    return card;\n  }\n\n  json() {\n    return this.fact.json();\n  }\n\n  // PRIVATE METHODS\n  // Sanitize input \n  static #sanitizeDate(rawDate: any): Date | null {\n    let date = null;\n    try {\n      let numTest = Number(rawDate);\n      if (!isNaN(numTest) \n          && Number.isInteger(numTest) \n          && numTest <= new Date().getFullYear()) {\n\n            // TODO date comparison bad for cards with current year, because\n            // they include exact time if created after Now card?\n            date = new Date();\n            date.setFullYear(numTest);\n        } else {\n          throw new Error(`Bad date input ${rawDate}`);\n        }\n    } catch(e) { \n      console.error(e);\n    }\n    return date;\n  }\n\n  static async #sanitizeImg(url: string): string | null {\n    function getImageIfExists(url: string): Promise { \n      return new Promise((resolve, reject) => {\n        const img = new Image();\n        img.src = url;\n        img.onload = () => resolve(true);\n        img.onerror = () => resolve(false);\n      });\n    }\n    let testedUrl = null;\n    try {\n      if (url) {\n        let imgTest = await getImageIfExists(url).catch(console.log);\n        if (imgTest === true) {\n          testedUrl = url;\n        } else {\n          throw new Error(`Image not found at url '${url}'`);\n        }\n      } \n    } catch(e) {\n      console.error(e);\n    }\n    return testedUrl;\n  }\n\n  /**\n   * Return the year if positive or year BC if negative. (Deals with the year\n   * only.) \n   *\n   * Technically BC should be offset by one year but we told users to use\n   * negative numbers as years BC.\n   *\n   * Returns: Formatted string for year, with BC if the year was\n   * negative\n   */\n  dateToString(): string { \n    if (this.isClue) {\n      return \"Clue\";\n    } else {\n      let yearZero = new Date();\n      yearZero.setFullYear(0);\n\n      let displayYear = this.fact.year;\n      if (this.fact.date < yearZero) {\n        displayYear = `${-displayYear} bce`; \n      } \n      return displayYear;\n    }\n  }\n\n  // Return the date as YYYY year string.\n  get year(): string { \n    return this.fact.year; \n  }\n\n  copyAsAnswer(): FactCard {\n    return new FactCard({ ...this, isClue: false});\n  }\n\n  flash(): FactCard {\n    this.flash = true;\n    return this;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}