{"ast":null,"code":"export default class Timeline {\n  constructor({\n    id = -1,\n    title = \"\",\n    description = \"\",\n    keywords = [],\n    creator = \"\",\n    facts = []\n  } = {}) {\n    this.id = void 0;\n    this.title = void 0;\n    this.description = void 0;\n    this.keywords = void 0;\n    this.creator = void 0;\n    this.facts = void 0;\n    this.id = id;\n    this.title = title;\n    this.description = description;\n    this.keywords = keywords;\n    this.creator = creator;\n    this.facts = facts;\n  }\n  static parseKeywords(inputStr = \"\") {\n    if (inputStr) {\n      return inputStr.split(\";\").map(s => s.trim());\n    } else {\n      return [];\n    }\n  }\n  get keywordString() {\n    return this.keywords.join(\"; \");\n  }\n  static newFromKeywordString({\n    id,\n    title,\n    description,\n    keywords,\n    creator,\n    facts\n  }) {\n    return new Timeline({\n      id: id,\n      title: title,\n      description: description,\n      keywords: keywords ? Timeline.parseKeywords(keywords) : [],\n      creator: creator,\n      facts: facts\n    });\n  }\n  json() {\n    return JSON.stringify({\n      id: this.id,\n      title: this.title,\n      description: this.description,\n      keywords: this.keywordString,\n      creator: this.creator,\n      facts: this.facts.map(e => e.json())\n    });\n  }\n  sortByDate() {\n    this.facts.sort((c1, c2) => c1.date - c2.date);\n    return this;\n  }\n  addFact(fact) {\n    let newTimeline = new Timeline({\n      ...this,\n      facts: [...this.facts, fact]\n    });\n    return newTimeline.sortByDate();\n  }\n  removeFact(fact) {\n    let filtered = this.facts.filter(f => f !== fact);\n    return new Timeline({\n      ...this,\n      facts: filtered\n    });\n  }\n  addFacts(facts) {\n    let newTimeline = new Timeline({\n      ...this,\n      facts: [...this.facts, ...facts]\n    });\n    return newTimeline.sortByDate();\n  }\n  equals(other) {\n    let levelOne = Object.entries(this).every(([key, value]) => value === other[key]);\n    let [kw, otherKw] = [this.keywords, other.keywords];\n    let keywordTest = kw.length === otherKw.length && kw.every(k => otherKw.includes(k));\n    let [facts, otherFacts] = [this.facts, other.facts];\n    let factTest = facts.length === otherFacts.length && facts.every((f, index) => f.equals(otherFacts[index]));\n    return levelOne && keywordTest && factTest;\n  }\n  static async listTimelines(token = \"\") {\n    let list = null;\n    let response = await BackendRequest.fetch({\n      url: \"timelines/\",\n      method: \"POST\",\n      token: token\n    });\n    if (response.ok) {\n      let json = await response.json();\n      list = json;\n      debug(`Loaded list of ${json.length} timelines`);\n    } else {\n      debug(`Problem retrieving quiz list: Server responded ${response.status}, ${response.statusText}`);\n    }\n    return list;\n  }\n  static async newFromBackend(id, token) {\n    let newTimeline = null;\n    let response = await BackendRequest.fetch({\n      url: `timeline-full/${id}/`,\n      method: \"GET\",\n      token: token\n    });\n    if (response.ok) {\n      let json = await response.json();\n      debug(json);\n      // TODO don't need this because we always set a creator field when\n      // creating\n      // let creator = (json.creator === \"\") ? this.username : json.creator;\n\n      newTimeline = new Timeline({\n        id: json.id,\n        title: json.title,\n        description: json.description,\n        keywords: Timeline.parseKeywords(json.keywords),\n        creator: json.creator,\n        facts: json.facts.map(f => Fact.newFromYear(f))\n      });\n    } else {\n      debug(`Problem loading timeline with id ${id}: Server status ${response.status}, ${response.statusText}`);\n    }\n    return newTimeline;\n  }\n}","map":{"version":3,"names":["Timeline","constructor","id","title","description","keywords","creator","facts","parseKeywords","inputStr","split","map","s","trim","keywordString","join","newFromKeywordString","json","JSON","stringify","e","sortByDate","sort","c1","c2","date","addFact","fact","newTimeline","removeFact","filtered","filter","f","addFacts","equals","other","levelOne","Object","entries","every","key","value","kw","otherKw","keywordTest","length","k","includes","otherFacts","factTest","index","listTimelines","token","list","response","BackendRequest","fetch","url","method","ok","debug","status","statusText","newFromBackend","Fact","newFromYear"],"sources":["/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/src/classes/Timeline.tsx"],"sourcesContent":["interface TimelineInput {\n  id: number;\n  title: string;\n  description: string;\n  keywords: Array<string>;\n  creator: string;\n  facts: FactList;\n}\n\nexport default class Timeline {\n  id: number;\n  title: string;\n  description: string;\n  keywords: Array<string>;\n  creator: string;\n  facts: Array<Fact>;\n\n  constructor({ \n    id = -1,\n    title = \"\", \n    description = \"\", \n    keywords = [], \n    creator = \"\", \n    facts = []\n  }: TimelineInput = {}) {\n    this.id = id;\n    this.title = title;\n    this.description = description;\n    this.keywords = keywords;\n    this.creator = creator;\n    this.facts = facts;\n  }\n\n  static parseKeywords(inputStr: string = \"\"): Array<string> {\n    if (inputStr) {\n      return inputStr.split(\";\").map(s => s.trim());\n    } else {\n      return [];\n    }\n  }\n\n  get keywordString() {\n    return this.keywords.join(\"; \");\n  }\n\n  static newFromKeywordString({ id, title, description, keywords, creator, facts }) {\n    return new Timeline({\n      id: id,\n      title: title,\n      description: description,\n      keywords: keywords ? Timeline.parseKeywords(keywords) : [],\n      creator: creator,\n      facts: facts\n    });\n  }\n\n  json() {\n    return JSON.stringify({\n      id: this.id,\n      title: this.title,\n      description: this.description,\n      keywords: this.keywordString,\n      creator: this.creator,\n      facts: this.facts.map(e => e.json())\n     });\n  }\n\n  sortByDate() {\n    this.facts.sort((c1, c2) => c1.date - c2.date);\n    return this;\n  }\n\n  addFact(fact) {\n    let newTimeline = new Timeline({\n      ...this,\n      facts: [...this.facts, fact]\n    });\n    return newTimeline.sortByDate();\n  }\n\n  removeFact(fact) {\n    let filtered = this.facts.filter(f => f !== fact);\n    return new Timeline({\n      ...this,\n      facts: filtered\n    });\n  }\n\n  addFacts(facts) {\n    let newTimeline = new Timeline({\n      ...this,\n      facts: [...this.facts, ...facts]\n    });\n    return newTimeline.sortByDate();\n  }\n\n  equals(other: Timeline): boolean {\n    let levelOne = Object.entries(this).every(\n      ([key, value]) => value === other[key]);\n\n    let [kw, otherKw] = [this.keywords, other.keywords];\n    let keywordTest = (kw.length === otherKw.length) \n    && kw.every(k => otherKw.includes(k));\n\n    let [facts, otherFacts] = [this.facts, other.facts];\n    let factTest = (facts.length === otherFacts.length)\n    && facts.every((f, index) => f.equals(otherFacts[index]));\n\n    return levelOne && keywordTest && factTest;\n  }\n  \n  static async listTimelines(token: string = \"\"): array<string> {\n    let list = null;\n    let response = await BackendRequest.fetch({\n      url: \"timelines/\", \n      method: \"POST\", \n      token: token\n    });\n    if (response.ok) {\n      let json = await response.json();\n      list = json;\n      debug(`Loaded list of ${json.length} timelines`);\n    } else {\n      debug(`Problem retrieving quiz list: Server responded ${response.status}, ${response.statusText}`);\n    }\n    return list;\n  } \n\n  static async newFromBackend(id: number, token: string): Timeline {\n    let newTimeline = null;\n\n    let response = await BackendRequest.fetch({\n      url: `timeline-full/${id}/`, \n      method: \"GET\",\n      token: token\n    });\n\n    if (response.ok) {\n      let json = await response.json();\n      debug(json);\n      // TODO don't need this because we always set a creator field when\n      // creating\n      // let creator = (json.creator === \"\") ? this.username : json.creator;\n\n      newTimeline = new Timeline({\n        id:           json.id,\n        title:        json.title,\n        description:  json.description,\n        keywords:     Timeline.parseKeywords(json.keywords),\n        creator:      json.creator,\n        facts:        json.facts.map(f => Fact.newFromYear(f))\n      });\n    } else {\n      debug(`Problem loading timeline with id ${id}: Server status ${response.status}, ${response.statusText}`);\n    }\n\n    return newTimeline;\n  }\n\n}\n\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}