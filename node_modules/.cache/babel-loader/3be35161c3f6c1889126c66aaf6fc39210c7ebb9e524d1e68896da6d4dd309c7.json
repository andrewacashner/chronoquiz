{"ast":null,"code":"import Card from \"./Card\";\nimport Fact from \"./Fact\";\nimport FactList from \"./FactList\";\nimport { default as Color } from \"./RgbColorMix\";\nexport default class Game {\n  constructor({\n    clues,\n    timeline,\n    score = 0,\n    isActive = false,\n    isGameOver = false\n  } = {}) {\n    this.clues = void 0;\n    this.timeline = void 0;\n    this.score = void 0;\n    this.isActive = void 0;\n    this.isGameOver = void 0;\n    this.clues = clues;\n    this.timeline = timeline;\n    this.score = score;\n    this.isActive = isActive;\n    this.isGameOver = isGameOver;\n  }\n  // PRIVATE METHODS\n\n  /** Remove last item of clue list and add it to timeline list.\n   * (Note: The timeline list will then shuffle itself in chronological\n   * order.)\n   */\n  moveCurrentClueToTimeline() {\n    let answer = this.clues.pop();\n    answer.isClue = false;\n    this.timeline.addFact(answer);\n    return this;\n  }\n  copyWithNextClue() {\n    let answer = this.clues.last().copyAsAnswer();\n    let newTimeline = this.timeline.addAnswer(answer);\n    let newClues = this.clues.dropLastCopy();\n    let gameOver = newClues.isEmpty();\n    return new Game({\n      clues: newClues,\n      timeline: newTimeline,\n      score: this.score,\n      isActive: this.isActive,\n      isGameOver: gameOver\n    });\n  }\n\n  // PUBLIC METHODS\n\n  // Start the game with just a \"Now\" card in the timeline.\n  // Since we have the image locally we don't need to sanitize the card.\n  static startingGame() {\n    let NowCard = new Card({\n      isClue: false,\n      fact: new Fact({\n        date: new Date(),\n        info: \"Now\",\n        img: \"../img/hourglass.jpg\"\n      }),\n      color: Color.VIOLET\n    });\n    NowCard.markSafe();\n    return new Game({\n      clues: new FactList(),\n      timeline: new FactList([NowCard]),\n      score: 0\n    });\n  }\n  incrementScore() {\n    ++this.score;\n    return this;\n  }\n\n  // Subtract one from score; don't go below zero\n  decrementScore() {\n    this.score = Math.max(0, this.score - 1);\n    return this;\n  }\n}","map":{"version":3,"names":["Card","Fact","FactList","default","Color","Game","constructor","clues","timeline","score","isActive","isGameOver","moveCurrentClueToTimeline","answer","pop","isClue","addFact","copyWithNextClue","last","copyAsAnswer","newTimeline","addAnswer","newClues","dropLastCopy","gameOver","isEmpty","startingGame","NowCard","fact","date","Date","info","img","color","VIOLET","markSafe","incrementScore","decrementScore","Math","max"],"sources":["/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/src/classes/Game.tsx"],"sourcesContent":["import Card from \"./Card\";\nimport Fact from \"./Fact\";\nimport FactList from \"./FactList\";\nimport { default as Color } from \"./RgbColorMix\";\n\ninterface GameInput {\n  clues: FactList;\n  timeline: FactList;\n  score: number;\n}\n\nexport default class Game {\n  clues: FactList;\n  timeline: FactList;\n  score: number;\n  isActive: boolean;\n  isGameOver: boolean;\n\n  constructor({ clues, timeline, score = 0, isActive = false, isGameOver = false }: GameInput = {}) {\n    this.clues = clues;\n    this.timeline = timeline;\n    this.score = score;\n    this.isActive = isActive;\n    this.isGameOver = isGameOver;\n  }\n  // PRIVATE METHODS\n  \n  /** Remove last item of clue list and add it to timeline list.\n   * (Note: The timeline list will then shuffle itself in chronological\n   * order.)\n   */\n  moveCurrentClueToTimeline(): Game {\n    let answer = this.clues.pop();\n    answer.isClue = false;\n    this.timeline.addFact(answer);\n    return this;\n  }\n\n  copyWithNextClue(): Game {\n    let answer = this.clues.last().copyAsAnswer();\n    let newTimeline = this.timeline.addAnswer(answer);\n    \n    let newClues = this.clues.dropLastCopy();\n    let gameOver = newClues.isEmpty();\n\n    return new Game({\n      clues: newClues,\n      timeline: newTimeline,\n      score: this.score,\n      isActive: this.isActive,\n      isGameOver: gameOver\n    });\n  }\n\n  // PUBLIC METHODS\n \n  // Start the game with just a \"Now\" card in the timeline.\n  // Since we have the image locally we don't need to sanitize the card.\n  static startingGame(): Game {\n    let NowCard = new Card({\n      isClue: false, \n      fact: new Fact({ \n        date: new Date(), \n        info: \"Now\", \n        img: \"../img/hourglass.jpg\"\n      }),\n      color: Color.VIOLET\n    });\n    NowCard.markSafe();\n\n    return new Game({\n      clues: new FactList(), \n      timeline: new FactList([NowCard]),\n      score: 0\n    });\n  }\n\n  incrementScore(): Game {\n    ++this.score;\n    return this;\n  }\n\n  // Subtract one from score; don't go below zero\n  decrementScore(): Game {\n    this.score  = Math.max(0, this.score - 1);\n    return this;\n  }\n\n}\n"],"mappings":"AAAA,OAAOA,IAAI,MAAM,QAAQ;AACzB,OAAOC,IAAI,MAAM,QAAQ;AACzB,OAAOC,QAAQ,MAAM,YAAY;AACjC,SAASC,OAAO,IAAIC,KAAK,QAAQ,eAAe;AAQhD,eAAe,MAAMC,IAAI,CAAC;EAOxBC,WAAWA,CAAC;IAAEC,KAAK;IAAEC,QAAQ;IAAEC,KAAK,GAAG,CAAC;IAAEC,QAAQ,GAAG,KAAK;IAAEC,UAAU,GAAG;EAAiB,CAAC,GAAG,CAAC,CAAC,EAAE;IAAA,KANlGJ,KAAK;IAAA,KACLC,QAAQ;IAAA,KACRC,KAAK;IAAA,KACLC,QAAQ;IAAA,KACRC,UAAU;IAGR,IAAI,CAACJ,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,UAAU,GAAGA,UAAU;EAC9B;EACA;;EAEA;AACF;AACA;AACA;EACEC,yBAAyBA,CAAA,EAAS;IAChC,IAAIC,MAAM,GAAG,IAAI,CAACN,KAAK,CAACO,GAAG,CAAC,CAAC;IAC7BD,MAAM,CAACE,MAAM,GAAG,KAAK;IACrB,IAAI,CAACP,QAAQ,CAACQ,OAAO,CAACH,MAAM,CAAC;IAC7B,OAAO,IAAI;EACb;EAEAI,gBAAgBA,CAAA,EAAS;IACvB,IAAIJ,MAAM,GAAG,IAAI,CAACN,KAAK,CAACW,IAAI,CAAC,CAAC,CAACC,YAAY,CAAC,CAAC;IAC7C,IAAIC,WAAW,GAAG,IAAI,CAACZ,QAAQ,CAACa,SAAS,CAACR,MAAM,CAAC;IAEjD,IAAIS,QAAQ,GAAG,IAAI,CAACf,KAAK,CAACgB,YAAY,CAAC,CAAC;IACxC,IAAIC,QAAQ,GAAGF,QAAQ,CAACG,OAAO,CAAC,CAAC;IAEjC,OAAO,IAAIpB,IAAI,CAAC;MACdE,KAAK,EAAEe,QAAQ;MACfd,QAAQ,EAAEY,WAAW;MACrBX,KAAK,EAAE,IAAI,CAACA,KAAK;MACjBC,QAAQ,EAAE,IAAI,CAACA,QAAQ;MACvBC,UAAU,EAAEa;IACd,CAAC,CAAC;EACJ;;EAEA;;EAEA;EACA;EACA,OAAOE,YAAYA,CAAA,EAAS;IAC1B,IAAIC,OAAO,GAAG,IAAI3B,IAAI,CAAC;MACrBe,MAAM,EAAE,KAAK;MACba,IAAI,EAAE,IAAI3B,IAAI,CAAC;QACb4B,IAAI,EAAE,IAAIC,IAAI,CAAC,CAAC;QAChBC,IAAI,EAAE,KAAK;QACXC,GAAG,EAAE;MACP,CAAC,CAAC;MACFC,KAAK,EAAE7B,KAAK,CAAC8B;IACf,CAAC,CAAC;IACFP,OAAO,CAACQ,QAAQ,CAAC,CAAC;IAElB,OAAO,IAAI9B,IAAI,CAAC;MACdE,KAAK,EAAE,IAAIL,QAAQ,CAAC,CAAC;MACrBM,QAAQ,EAAE,IAAIN,QAAQ,CAAC,CAACyB,OAAO,CAAC,CAAC;MACjClB,KAAK,EAAE;IACT,CAAC,CAAC;EACJ;EAEA2B,cAAcA,CAAA,EAAS;IACrB,EAAE,IAAI,CAAC3B,KAAK;IACZ,OAAO,IAAI;EACb;;EAEA;EACA4B,cAAcA,CAAA,EAAS;IACrB,IAAI,CAAC5B,KAAK,GAAI6B,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC9B,KAAK,GAAG,CAAC,CAAC;IACzC,OAAO,IAAI;EACb;AAEF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}