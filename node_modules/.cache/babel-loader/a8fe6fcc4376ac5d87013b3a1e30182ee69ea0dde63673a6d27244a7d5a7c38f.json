{"ast":null,"code":"import _classPrivateFieldLooseBase from\"/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";import _classPrivateFieldLooseKey from\"/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";var _safe=/*#__PURE__*/_classPrivateFieldLooseKey(\"safe\");var _sanitizeDate=/*#__PURE__*/_classPrivateFieldLooseKey(\"sanitizeDate\");var _sanitizeImg=/*#__PURE__*/_classPrivateFieldLooseKey(\"sanitizeImg\");export default class Card{// Has this card been sanitized?\n// Each card gets the given info and a random unique identifier.\nconstructor(_ref){let{isClue=true,date,info,img,color=null,expand=false,flash=false}=_ref;this.isClue=void 0;this.id=void 0;this.date=void 0;this.info=void 0;this.img=void 0;this.color=void 0;// CSS color to be used in timeline\nthis.expand=void 0;// Add margin because a card is being dragged over?\nthis.flash=void 0;// Should this card flash an alert? (For wrong guess)\nObject.defineProperty(this,_safe,{writable:true,value:void 0});this.isClue=isClue;this.id=crypto.randomUUID();this.date=date;this.info=info;this.img=img;this.color=color;this.expand=expand;this.flash=flash;_classPrivateFieldLooseBase(this,_safe)[_safe]=false;// Has this card been sanitized?\n}markSafe(){_classPrivateFieldLooseBase(this,_safe)[_safe]=true;return this;}// PUBLIC METHODS\nget isSafe(){return _classPrivateFieldLooseBase(this,_safe)[_safe];}/** Creat a new card with sanitized input.\n   * - The date must be an integer string <= the current year (including\n   *   negative numbers).\n   * - The info is converted to plain text using textContent.\n   * - The image, if present, is downloaded and cached.\n   *\n   * The parameters are the same as for new Card().\n   *\n   * Returns: Card with validated content (with safe property set to true), or\n   * null if the input was invalid.\n   */static async newSafeCard(_ref2){let{isClue,date,info,img}=_ref2;let card=null;try{let cleanDate=_classPrivateFieldLooseBase(Card,_sanitizeDate)[_sanitizeDate](date);let cleanInfo=info;// React already sanitizes (?)\nlet cleanImg=await _classPrivateFieldLooseBase(Card,_sanitizeImg)[_sanitizeImg](img).catch(console.error);// The date is the only dealbreaker. We just skip a bad image link.\nif(cleanDate){card=new Card({isClue:isClue,date:cleanDate,info:cleanInfo,img:cleanImg});card.markSafe();return card;}else{throw new Error(\"Could not sanitize card input with date '\".concat(date,\"', info '\").concat(info,\"'\"));}}catch(e){console.error(e);}return card;}// PRIVATE METHODS\n// Sanitize input \n/**\n   * Return the year if positive or year BC if negative. (Deals with the year\n   * only.) \n   *\n   * Technically BC should be offset by one year but we told users to use\n   * negative numbers as years BC.\n   *\n   * Returns: Formatted string for year, with BC if the year was\n   * negative\n   */dateToString(){if(this.isClue){return\"Clue\";}else{let yearZero=new Date();yearZero.setFullYear(0);let displayYear=this.year;if(this.date<yearZero){displayYear=\"\".concat(-displayYear,\" bce\");}return displayYear;}}// Return the date as YYYY year string.\nget year(){return this.date.getFullYear();}copyAsAnswer(){return new Card({...this,isClue:false});}flash(){this.flash=true;return this;}}function _sanitizeDate2(rawDate){let date=null;try{// TODO bc. server gives format \"YYYY-MM-DD\"\nlet yyyy=rawDate.slice(0,4);let numTest=Number(yyyy);if(!isNaN(numTest)&&Number.isInteger(numTest)&&numTest<=new Date().getFullYear()){// TODO date comparison bad for cards with current year, because\n// they include exact time if created after Now card?\ndate=new Date();date.setFullYear(numTest);}else{throw new Error(\"Bad date input \".concat(rawDate));}}catch(e){console.error(e);}return date;}async function _sanitizeImg2(url){function getImageIfExists(url){return new Promise((resolve,reject)=>{const img=new Image();img.src=url;img.onload=()=>resolve(true);img.onerror=()=>resolve(false);});}let testedUrl=null;try{if(url){let imgTest=await getImageIfExists(url).catch(console.log);if(imgTest===true){testedUrl=url;}else{throw new Error(\"Image not found at url '\".concat(url,\"'\"));}}}catch(e){console.error(e);}return testedUrl;}Object.defineProperty(Card,_sanitizeImg,{value:_sanitizeImg2});Object.defineProperty(Card,_sanitizeDate,{value:_sanitizeDate2});","map":{"version":3,"names":["Card","constructor","_ref","isClue","date","info","img","color","expand","flash","id","Object","defineProperty","_safe","writable","value","crypto","randomUUID","_classPrivateFieldLooseBase","markSafe","isSafe","newSafeCard","_ref2","card","cleanDate","_sanitizeDate","cleanInfo","cleanImg","_sanitizeImg","catch","console","error","Error","concat","e","dateToString","yearZero","Date","setFullYear","displayYear","year","getFullYear","copyAsAnswer","_sanitizeDate2","rawDate","yyyy","slice","numTest","Number","isNaN","isInteger","_sanitizeImg2","url","getImageIfExists","Promise","resolve","reject","Image","src","onload","onerror","testedUrl","imgTest","log"],"sources":["/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/src/classes/Card.tsx"],"sourcesContent":["interface CardInput  {\n  isClue: boolean;      // Is this a clue (true) or answer?\n  date: Date | number | string;  // Date object or numeric year of event\n  // TODO return to this, depends on backend server output\n  info: string;         // Brief description of event\n  img: string;          // Full URL of image\n}\n\nexport default class Card {\n  isClue: boolean;\n  id: string;\n  date: Date; \n  info: string;\n  img: string;\n  color: string;    // CSS color to be used in timeline\n  expand: boolean;  // Add margin because a card is being dragged over?\n  flash: boolean;   // Should this card flash an alert? (For wrong guess)\n  #safe: boolean;   // Has this card been sanitized?\n\n  // Each card gets the given info and a random unique identifier.\n  constructor({ isClue = true, date, info, img, color = null, expand = false, flash = false }: CardInput) {\n    this.isClue = isClue;\n    this.id = crypto.randomUUID();\n    this.date = date;\n    this.info = info;\n    this.img = img;\n    this.color = color;\n    this.expand = expand;\n    this.flash = flash;\n    this.#safe = false; // Has this card been sanitized?\n  }\n\n  markSafe(): Card {\n    this.#safe = true;\n    return this;\n  }\n\n  // PUBLIC METHODS\n\n  get isSafe(): boolean {\n    return this.#safe;\n  }\n\n  /** Creat a new card with sanitized input.\n   * - The date must be an integer string <= the current year (including\n   *   negative numbers).\n   * - The info is converted to plain text using textContent.\n   * - The image, if present, is downloaded and cached.\n   *\n   * The parameters are the same as for new Card().\n   *\n   * Returns: Card with validated content (with safe property set to true), or\n   * null if the input was invalid.\n   */\n  static async newSafeCard({ isClue, date, info, img }: \n                           CardInput): Card | null {\n    let card = null;\n    try {\n      let cleanDate = Card.#sanitizeDate(date);\n      let cleanInfo = info; // React already sanitizes (?)\n      let cleanImg = await Card.#sanitizeImg(img).catch(console.error);\n\n      // The date is the only dealbreaker. We just skip a bad image link.\n      if (cleanDate) {\n        card = new Card({\n          isClue: isClue, \n          date: cleanDate, \n          info: cleanInfo, \n          img: cleanImg\n        });\n        card.markSafe();\n        return card;\n      } else {\n        throw new Error(`Could not sanitize card input with date '${date}', info '${info}'`);\n      }\n    } catch(e) {\n      console.error(e);\n    }\n    return card;\n  }\n\n  // PRIVATE METHODS\n  // Sanitize input \n  static #sanitizeDate(rawDate: any): Date | null {\n    let date = null;\n    try {\n      // TODO bc. server gives format \"YYYY-MM-DD\"\n      let yyyy = rawDate.slice(0, 4); \n\n      let numTest = Number(yyyy);\n      if (!isNaN(numTest) \n          && Number.isInteger(numTest) \n          && numTest <= new Date().getFullYear()) {\n\n            // TODO date comparison bad for cards with current year, because\n            // they include exact time if created after Now card?\n            date = new Date();\n            date.setFullYear(numTest);\n        } else {\n          throw new Error(`Bad date input ${rawDate}`);\n        }\n    } catch(e) { \n      console.error(e);\n    }\n    return date;\n  }\n\n  static async #sanitizeImg(url: string): string | null {\n    function getImageIfExists(url: string): Promise { \n      return new Promise((resolve, reject) => {\n        const img = new Image();\n        img.src = url;\n        img.onload = () => resolve(true);\n        img.onerror = () => resolve(false);\n      });\n    }\n    let testedUrl = null;\n    try {\n      if (url) {\n        let imgTest = await getImageIfExists(url).catch(console.log);\n        if (imgTest === true) {\n          testedUrl = url;\n        } else {\n          throw new Error(`Image not found at url '${url}'`);\n        }\n      } \n    } catch(e) {\n      console.error(e);\n    }\n    return testedUrl;\n  }\n\n  /**\n   * Return the year if positive or year BC if negative. (Deals with the year\n   * only.) \n   *\n   * Technically BC should be offset by one year but we told users to use\n   * negative numbers as years BC.\n   *\n   * Returns: Formatted string for year, with BC if the year was\n   * negative\n   */\n  dateToString(): string { \n    if (this.isClue) {\n      return \"Clue\";\n    } else {\n      let yearZero = new Date();\n      yearZero.setFullYear(0);\n\n      let displayYear = this.year;\n      if (this.date < yearZero) {\n        displayYear = `${-displayYear} bce`; \n      } \n      return displayYear;\n    }\n  }\n\n  // Return the date as YYYY year string.\n  get year(): string { return this.date.getFullYear(); }\n\n  copyAsAnswer(): Card {\n    return new Card({ ...this, isClue: false});\n  }\n\n  flash(): Card {\n    this.flash = true;\n    return this;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}