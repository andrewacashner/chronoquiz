{"ast":null,"code":"import _classPrivateFieldLooseBase from \"/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";\nimport _classPrivateFieldLooseKey from \"/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";\nimport Fact from \"./Fact\";\nvar _safe = /*#__PURE__*/_classPrivateFieldLooseKey(\"safe\");\nvar _sanitizeDate = /*#__PURE__*/_classPrivateFieldLooseKey(\"sanitizeDate\");\nvar _sanitizeImg = /*#__PURE__*/_classPrivateFieldLooseKey(\"sanitizeImg\");\nexport default class FactCard {\n  // Has this card been sanitized?\n\n  // Each card gets the given info and a random unique identifier.\n  constructor({\n    isClue = true,\n    fact = new Fact(),\n    color = null,\n    expand = false,\n    flash = false\n  }) {\n    this.isClue = void 0;\n    this.id = void 0;\n    this.fact = void 0;\n    this.color = void 0;\n    // CSS color to be used in timeline\n    this.expand = void 0;\n    // Add margin because a card is being dragged over?\n    this.flash = void 0;\n    // Should this card flash an alert? (For wrong guess)\n    Object.defineProperty(this, _safe, {\n      writable: true,\n      value: void 0\n    });\n    this.isClue = isClue;\n    this.id = crypto.randomUUID();\n    this.fact = fact;\n    this.color = color;\n    this.expand = expand;\n    this.flash = flash;\n    _classPrivateFieldLooseBase(this, _safe)[_safe] = false; // Has this card been sanitized?\n  }\n  markSafe() {\n    _classPrivateFieldLooseBase(this, _safe)[_safe] = true;\n    return this;\n  }\n\n  // PUBLIC METHODS\n\n  get isSafe() {\n    return _classPrivateFieldLooseBase(this, _safe)[_safe];\n  }\n\n  /** Creat a new card with sanitized input.\n   * - The date must be an integer string <= the current year (including\n   *   negative numbers).\n   * - The info is converted to plain text using textContent.\n   * - The image, if present, is downloaded and cached.\n   *\n   * The parameters are the same as for new FactCard().\n   *\n   * Returns: FactCard with validated content (with safe property set to true), or\n   * null if the input was invalid.\n   */\n  static async newSafeFactCard({\n    isClue,\n    date,\n    info,\n    img\n  }) {\n    let card = null;\n    try {\n      let cleanDate = _classPrivateFieldLooseBase(FactCard, _sanitizeDate)[_sanitizeDate](date);\n      let cleanInfo = info;\n      let cleanImg = await _classPrivateFieldLooseBase(FactCard, _sanitizeImg)[_sanitizeImg](img).catch(console.error);\n\n      // The date is the only dealbreaker. We just skip a bad image link.\n      if (cleanDate) {\n        card = new FactCard({\n          isClue: isClue,\n          fact: new Fact({\n            date: cleanDate,\n            info: cleanInfo,\n            img: cleanImg\n          })\n        });\n        card.markSafe();\n        return card;\n      } else {\n        throw new Error(`Could not sanitize card input with date '${date}', info '${info}'`);\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    return card;\n  }\n  json() {\n    return this.fact.json();\n  }\n\n  // PRIVATE METHODS\n  // Sanitize input \n\n  /**\n   * Return the year if positive or year BC if negative. (Deals with the year\n   * only.) \n   *\n   * Technically BC should be offset by one year but we told users to use\n   * negative numbers as years BC.\n   *\n   * Returns: Formatted string for year, with BC if the year was\n   * negative\n   */\n  dateToString() {\n    if (this.isClue) {\n      return \"Clue\";\n    } else {\n      let yearZero = new Date();\n      yearZero.setFullYear(0);\n      let displayYear = this.fact.year;\n      if (this.fact.date < yearZero) {\n        displayYear = `${-displayYear} bce`;\n      }\n      return displayYear;\n    }\n  }\n\n  // Return the date as YYYY year string.\n  get year() {\n    return this.fact.year;\n  }\n  copyAsAnswer() {\n    return new FactCard({\n      ...this,\n      isClue: false\n    });\n  }\n  flash() {\n    this.flash = true;\n    return this;\n  }\n}\nfunction _sanitizeDate2(rawDate) {\n  let date = null;\n  try {\n    let numTest = Number(rawDate);\n    if (!isNaN(numTest) && Number.isInteger(numTest) && numTest <= new Date().getFullYear()) {\n      // TODO date comparison bad for cards with current year, because\n      // they include exact time if created after Now card?\n      date = new Date();\n      date.setFullYear(numTest);\n    } else {\n      throw new Error(`Bad date input ${rawDate}`);\n    }\n  } catch (e) {\n    console.error(e);\n  }\n  return date;\n}\nasync function _sanitizeImg2(url) {\n  function getImageIfExists(url) {\n    return new Promise((resolve, reject) => {\n      const img = new Image();\n      img.src = url;\n      img.onload = () => resolve(true);\n      img.onerror = () => resolve(false);\n    });\n  }\n  let testedUrl = null;\n  try {\n    if (url) {\n      let imgTest = await getImageIfExists(url).catch(console.log);\n      if (imgTest === true) {\n        testedUrl = url;\n      } else {\n        throw new Error(`Image not found at url '${url}'`);\n      }\n    }\n  } catch (e) {\n    console.error(e);\n  }\n  return testedUrl;\n}\nObject.defineProperty(FactCard, _sanitizeImg, {\n  value: _sanitizeImg2\n});\nObject.defineProperty(FactCard, _sanitizeDate, {\n  value: _sanitizeDate2\n});","map":{"version":3,"names":["Fact","_safe","_classPrivateFieldLooseKey","_sanitizeDate","_sanitizeImg","FactCard","constructor","isClue","fact","color","expand","flash","id","Object","defineProperty","writable","value","crypto","randomUUID","_classPrivateFieldLooseBase","markSafe","isSafe","newSafeFactCard","date","info","img","card","cleanDate","cleanInfo","cleanImg","catch","console","error","Error","e","json","dateToString","yearZero","Date","setFullYear","displayYear","year","copyAsAnswer","_sanitizeDate2","rawDate","numTest","Number","isNaN","isInteger","getFullYear","_sanitizeImg2","url","getImageIfExists","Promise","resolve","reject","Image","src","onload","onerror","testedUrl","imgTest","log"],"sources":["/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/src/classes/FactCard.tsx"],"sourcesContent":["import Fact from \"./Fact\";\n\ninterface FactCardInput  {\n  isClue: boolean;      // Is this a clue (true) or answer?\n  fact: Fact;\n}\n\nexport default class FactCard {\n  isClue: boolean;\n  id: string;\n  fact: Fact;\n  color: string;    // CSS color to be used in timeline\n  expand: boolean;  // Add margin because a card is being dragged over?\n  flash: boolean;   // Should this card flash an alert? (For wrong guess)\n  #safe: boolean;   // Has this card been sanitized?\n\n  // Each card gets the given info and a random unique identifier.\n  constructor({ isClue = true, fact = new Fact(), color = null, expand = false, flash = false }: FactCardInput) {\n    this.isClue = isClue;\n    this.id = crypto.randomUUID();\n    this.fact = fact;\n    this.color = color;\n    this.expand = expand;\n    this.flash = flash;\n    this.#safe = false; // Has this card been sanitized?\n  }\n\n  markSafe(): FactCard {\n    this.#safe = true;\n    return this;\n  }\n\n  // PUBLIC METHODS\n\n  get isSafe(): boolean {\n    return this.#safe;\n  }\n\n  /** Creat a new card with sanitized input.\n   * - The date must be an integer string <= the current year (including\n   *   negative numbers).\n   * - The info is converted to plain text using textContent.\n   * - The image, if present, is downloaded and cached.\n   *\n   * The parameters are the same as for new FactCard().\n   *\n   * Returns: FactCard with validated content (with safe property set to true), or\n   * null if the input was invalid.\n   */\n  static async newSafeFactCard({ isClue, date, info, img }: \n                           FactCardInput): FactCard | null {\n    let card = null;\n    try {\n      let cleanDate = FactCard.#sanitizeDate(date);\n      let cleanInfo = info;\n      let cleanImg = await FactCard.#sanitizeImg(img).catch(console.error);\n\n      // The date is the only dealbreaker. We just skip a bad image link.\n      if (cleanDate) {\n        card = new FactCard({\n          isClue: isClue, \n          fact: new Fact({ date: cleanDate, info: cleanInfo, img: cleanImg})\n        });\n        card.markSafe();\n        return card;\n      } else {\n        throw new Error(`Could not sanitize card input with date '${date}', info '${info}'`);\n      }\n    } catch(e) {\n      console.error(e);\n    }\n    return card;\n  }\n\n  json() {\n    return this.fact.json();\n  }\n\n  // PRIVATE METHODS\n  // Sanitize input \n  static #sanitizeDate(rawDate: any): Date | null {\n    let date = null;\n    try {\n      let numTest = Number(rawDate);\n      if (!isNaN(numTest) \n          && Number.isInteger(numTest) \n          && numTest <= new Date().getFullYear()) {\n\n            // TODO date comparison bad for cards with current year, because\n            // they include exact time if created after Now card?\n            date = new Date();\n            date.setFullYear(numTest);\n        } else {\n          throw new Error(`Bad date input ${rawDate}`);\n        }\n    } catch(e) { \n      console.error(e);\n    }\n    return date;\n  }\n\n  static async #sanitizeImg(url: string): string | null {\n    function getImageIfExists(url: string): Promise { \n      return new Promise((resolve, reject) => {\n        const img = new Image();\n        img.src = url;\n        img.onload = () => resolve(true);\n        img.onerror = () => resolve(false);\n      });\n    }\n    let testedUrl = null;\n    try {\n      if (url) {\n        let imgTest = await getImageIfExists(url).catch(console.log);\n        if (imgTest === true) {\n          testedUrl = url;\n        } else {\n          throw new Error(`Image not found at url '${url}'`);\n        }\n      } \n    } catch(e) {\n      console.error(e);\n    }\n    return testedUrl;\n  }\n\n  /**\n   * Return the year if positive or year BC if negative. (Deals with the year\n   * only.) \n   *\n   * Technically BC should be offset by one year but we told users to use\n   * negative numbers as years BC.\n   *\n   * Returns: Formatted string for year, with BC if the year was\n   * negative\n   */\n  dateToString(): string { \n    if (this.isClue) {\n      return \"Clue\";\n    } else {\n      let yearZero = new Date();\n      yearZero.setFullYear(0);\n\n      let displayYear = this.fact.year;\n      if (this.fact.date < yearZero) {\n        displayYear = `${-displayYear} bce`; \n      } \n      return displayYear;\n    }\n  }\n\n  // Return the date as YYYY year string.\n  get year(): string { \n    return this.fact.year; \n  }\n\n  copyAsAnswer(): FactCard {\n    return new FactCard({ ...this, isClue: false});\n  }\n\n  flash(): FactCard {\n    this.flash = true;\n    return this;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}