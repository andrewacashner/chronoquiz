{"ast":null,"code":"import _classPrivateFieldLooseBase from \"/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";\nimport _classPrivateFieldLooseKey from \"/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";\nvar _safe = /*#__PURE__*/_classPrivateFieldLooseKey(\"safe\");\nvar _sanitizeDate = /*#__PURE__*/_classPrivateFieldLooseKey(\"sanitizeDate\");\nvar _sanitizeImg = /*#__PURE__*/_classPrivateFieldLooseKey(\"sanitizeImg\");\nexport default class Card {\n  // Has this card been sanitized?\n\n  // Each card gets the given info and a random unique identifier.\n  constructor({\n    isClue = true,\n    date,\n    info,\n    img,\n    color = null,\n    expand = false,\n    flash = false\n  }) {\n    this.isClue = void 0;\n    this.id = void 0;\n    this.date = void 0;\n    this.info = void 0;\n    this.img = void 0;\n    this.color = void 0;\n    // CSS color to be used in timeline\n    this.expand = void 0;\n    // Add margin because a card is being dragged over?\n    this.flash = void 0;\n    // Should this card flash an alert? (For wrong guess)\n    Object.defineProperty(this, _safe, {\n      writable: true,\n      value: void 0\n    });\n    this.isClue = isClue;\n    this.id = crypto.randomUUID();\n    this.date = date;\n    this.info = info;\n    this.img = img;\n    this.color = color;\n    this.expand = expand;\n    this.flash = flash;\n    _classPrivateFieldLooseBase(this, _safe)[_safe] = false; // Has this card been sanitized?\n  }\n  markSafe() {\n    _classPrivateFieldLooseBase(this, _safe)[_safe] = true;\n    return this;\n  }\n\n  // PUBLIC METHODS\n\n  get isSafe() {\n    return _classPrivateFieldLooseBase(this, _safe)[_safe];\n  }\n\n  /** Creat a new card with sanitized input.\n   * - The date must be an integer string <= the current year (including\n   *   negative numbers).\n   * - The info is converted to plain text using textContent.\n   * - The image, if present, is downloaded and cached.\n   *\n   * The parameters are the same as for new Card().\n   *\n   * Returns: Card with validated content (with safe property set to true), or\n   * null if the input was invalid.\n   */\n  static async newSafeCard({\n    isClue,\n    date,\n    info,\n    img\n  }) {\n    let card = null;\n    try {\n      let cleanDate = _classPrivateFieldLooseBase(Card, _sanitizeDate)[_sanitizeDate](date);\n      let cleanInfo = info; // React already sanitizes (?)\n      let cleanImg = await _classPrivateFieldLooseBase(Card, _sanitizeImg)[_sanitizeImg](img).catch(console.error);\n\n      // The date is the only dealbreaker. We just skip a bad image link.\n      if (cleanDate) {\n        card = new Card({\n          isClue: isClue,\n          date: cleanDate,\n          info: cleanInfo,\n          img: cleanImg\n        });\n        card.markSafe();\n        return card;\n      } else {\n        throw new Error(`Could not sanitize card input with date '${date}', info '${info}'`);\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    return card;\n  }\n\n  // PRIVATE METHODS\n  // Sanitize input \n\n  /**\n   * Return the year if positive or year BC if negative. (Deals with the year\n   * only.) \n   *\n   * Technically BC should be offset by one year but we told users to use\n   * negative numbers as years BC.\n   *\n   * Returns: Formatted string for year, with BC if the year was\n   * negative\n   */\n  dateToString() {\n    if (this.isClue) {\n      return \"Clue\";\n    } else {\n      let yearZero = new Date();\n      yearZero.setFullYear(0);\n      let displayYear = this.year;\n      if (this.date < yearZero) {\n        displayYear = `${-displayYear} bce`;\n      }\n      return displayYear;\n    }\n  }\n\n  // Return the date as YYYY year string.\n  get year() {\n    return this.date.getFullYear();\n  }\n  copyAsAnswer() {\n    return new Card({\n      ...this,\n      isClue: false\n    });\n  }\n  flash() {\n    this.flash = true;\n  }\n}\nfunction _sanitizeDate2(rawDate) {\n  let date = null;\n  try {\n    let numTest = Number(rawDate);\n    if (!isNaN(numTest) && Number.isInteger(numTest) && numTest <= new Date().getFullYear()) {\n      date = new Date();\n      date.setFullYear(numTest);\n    } else {\n      throw new Error(`Bad date input ${rawDate}`);\n    }\n  } catch (e) {\n    console.error(e);\n  }\n  return date;\n}\nasync function _sanitizeImg2(url) {\n  function getImageIfExists(url) {\n    return new Promise((resolve, reject) => {\n      const img = new Image();\n      img.src = url;\n      img.onload = () => resolve(true);\n      img.onerror = () => resolve(false);\n    });\n  }\n  let testedUrl = null;\n  try {\n    if (url) {\n      let imgTest = await getImageIfExists(url).catch(console.log);\n      if (imgTest === true) {\n        testedUrl = url;\n      } else {\n        throw new Error(`Image not found at url '${url}'`);\n      }\n    }\n  } catch (e) {\n    console.error(e);\n  }\n  return testedUrl;\n}\nObject.defineProperty(Card, _sanitizeImg, {\n  value: _sanitizeImg2\n});\nObject.defineProperty(Card, _sanitizeDate, {\n  value: _sanitizeDate2\n});","map":{"version":3,"names":["Card","constructor","isClue","date","info","img","color","expand","flash","id","Object","defineProperty","_safe","writable","value","crypto","randomUUID","_classPrivateFieldLooseBase","markSafe","isSafe","newSafeCard","card","cleanDate","_sanitizeDate","cleanInfo","cleanImg","_sanitizeImg","catch","console","error","Error","e","dateToString","yearZero","Date","setFullYear","displayYear","year","getFullYear","copyAsAnswer","_sanitizeDate2","rawDate","numTest","Number","isNaN","isInteger","_sanitizeImg2","url","getImageIfExists","Promise","resolve","reject","Image","src","onload","onerror","testedUrl","imgTest","log"],"sources":["/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/src/classes/Card.tsx"],"sourcesContent":["interface CardInput  {\n  isClue: boolean;      // Is this a clue (true) or answer?\n  date: Date | number;  // Date object or numeric year of event\n  info: string;         // Brief description of event\n  img: string;          // Full URL of image\n}\n\nexport default class Card {\n  isClue: boolean;\n  id: string;\n  date: Date; \n  info: string;\n  img: string;\n  color: string;    // CSS color to be used in timeline\n  expand: boolean;  // Add margin because a card is being dragged over?\n  flash: boolean;   // Should this card flash an alert? (For wrong guess)\n  #safe: boolean;   // Has this card been sanitized?\n\n  // Each card gets the given info and a random unique identifier.\n  constructor({ isClue = true, date, info, img, color = null, expand = false, flash = false }: CardInput) {\n    this.isClue = isClue;\n    this.id = crypto.randomUUID();\n    this.date = date;\n    this.info = info;\n    this.img = img;\n    this.color = color;\n    this.expand = expand;\n    this.flash = flash;\n    this.#safe = false; // Has this card been sanitized?\n  }\n\n  markSafe(): Card {\n    this.#safe = true;\n    return this;\n  }\n\n  // PUBLIC METHODS\n\n  get isSafe(): boolean {\n    return this.#safe;\n  }\n\n  /** Creat a new card with sanitized input.\n   * - The date must be an integer string <= the current year (including\n   *   negative numbers).\n   * - The info is converted to plain text using textContent.\n   * - The image, if present, is downloaded and cached.\n   *\n   * The parameters are the same as for new Card().\n   *\n   * Returns: Card with validated content (with safe property set to true), or\n   * null if the input was invalid.\n   */\n  static async newSafeCard({ isClue, date, info, img }: \n                           CardInput): Card | null {\n    let card = null;\n    try {\n      let cleanDate = Card.#sanitizeDate(date);\n      let cleanInfo = info; // React already sanitizes (?)\n      let cleanImg = await Card.#sanitizeImg(img).catch(console.error);\n\n      // The date is the only dealbreaker. We just skip a bad image link.\n      if (cleanDate) {\n        card = new Card({\n          isClue: isClue, \n          date: cleanDate, \n          info: cleanInfo, \n          img: cleanImg\n        });\n        card.markSafe();\n        return card;\n      } else {\n        throw new Error(`Could not sanitize card input with date '${date}', info '${info}'`);\n      }\n    } catch(e) {\n      console.error(e);\n    }\n    return card;\n  }\n\n  // PRIVATE METHODS\n  // Sanitize input \n  static #sanitizeDate(rawDate: any): Date | null {\n    let date = null;\n    try {\n      let numTest = Number(rawDate);\n      if (!isNaN(numTest) \n          && Number.isInteger(numTest) \n          && numTest <= new Date().getFullYear()) {\n            \n            date = new Date();\n            date.setFullYear(numTest);\n        } else {\n          throw new Error(`Bad date input ${rawDate}`);\n        }\n    } catch(e) { \n      console.error(e);\n    }\n    return date;\n  }\n\n  static async #sanitizeImg(url: string): string | null {\n    function getImageIfExists(url: string): Promise { \n      return new Promise((resolve, reject) => {\n        const img = new Image();\n        img.src = url;\n        img.onload = () => resolve(true);\n        img.onerror = () => resolve(false);\n      });\n    }\n    let testedUrl = null;\n    try {\n      if (url) {\n        let imgTest = await getImageIfExists(url).catch(console.log);\n        if (imgTest === true) {\n          testedUrl = url;\n        } else {\n          throw new Error(`Image not found at url '${url}'`);\n        }\n      } \n    } catch(e) {\n      console.error(e);\n    }\n    return testedUrl;\n  }\n\n  /**\n   * Return the year if positive or year BC if negative. (Deals with the year\n   * only.) \n   *\n   * Technically BC should be offset by one year but we told users to use\n   * negative numbers as years BC.\n   *\n   * Returns: Formatted string for year, with BC if the year was\n   * negative\n   */\n  dateToString(): string { \n    if (this.isClue) {\n      return \"Clue\";\n    } else {\n      let yearZero = new Date();\n      yearZero.setFullYear(0);\n\n      let displayYear = this.year;\n      if (this.date < yearZero) {\n        displayYear = `${-displayYear} bce`; \n      } \n      return displayYear;\n    }\n  }\n\n  // Return the date as YYYY year string.\n  get year(): string { return this.date.getFullYear(); }\n\n  copyAsAnswer(): Card {\n    return new Card({ ...this, isClue: false});\n  }\n\n  flash(): void {\n    this.flash = true;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}