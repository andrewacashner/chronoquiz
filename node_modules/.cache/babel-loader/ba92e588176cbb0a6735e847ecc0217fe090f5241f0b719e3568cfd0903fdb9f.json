{"ast":null,"code":"import _classPrivateFieldLooseBase from \"/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";\nimport _classPrivateFieldLooseKey from \"/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";\nvar _Card;\nvar _safe = /*#__PURE__*/_classPrivateFieldLooseKey(\"safe\");\nvar _markSafe = /*#__PURE__*/_classPrivateFieldLooseKey(\"markSafe\");\nvar _sanitizeDate = /*#__PURE__*/_classPrivateFieldLooseKey(\"sanitizeDate\");\nvar _sanitizeInfo = /*#__PURE__*/_classPrivateFieldLooseKey(\"sanitizeInfo\");\nvar _sanitizeImg = /*#__PURE__*/_classPrivateFieldLooseKey(\"sanitizeImg\");\nexport default class Card {\n  // Each card gets the given info and a random unique identifier.\n  constructor({\n    isClue = true,\n    date,\n    info,\n    img,\n    color\n  }) {\n    Object.defineProperty(this, _markSafe, {\n      value: _markSafe2\n    });\n    this.isClue = void 0;\n    this.id = void 0;\n    this.date = void 0;\n    this.info = void 0;\n    this.img = void 0;\n    this.color = void 0;\n    Object.defineProperty(this, _safe, {\n      writable: true,\n      value: void 0\n    });\n    this.isClue = isClue;\n    this.id = crypto.randomUUID();\n    this.date = new Date();\n    this.date.setFullYear(date);\n    this.info = info;\n    this.img = img;\n    this.color = color;\n    _classPrivateFieldLooseBase(this, _safe)[_safe] = false; // Has this card been sanitized?\n  }\n  // PUBLIC METHODS\n\n  get isSafe() {\n    return _classPrivateFieldLooseBase(this, _safe)[_safe];\n  }\n\n  /** Creat a new card with sanitized input.\n   * - The date must be an integer string <= the current year (including\n   *   negative numbers).\n   * - The info is converted to plain text using textContent.\n   * - The image, if present, is downloaded and cached.\n   *\n   * The parameters are the same as for new Card().\n   *\n   * Returns: Card with validated content (with safe property set to true), or\n   * null if the input was invalid.\n   */\n  static async newSafeCard({\n    isClue,\n    date,\n    info,\n    img,\n    color\n  }) {\n    let card = null;\n    try {\n      let cleanDate = _classPrivateFieldLooseBase(Card, _sanitizeDate)[_sanitizeDate](date);\n      let cleanInfo = _classPrivateFieldLooseBase(Card, _sanitizeInfo)[_sanitizeInfo](info);\n      let cleanImg = await _classPrivateFieldLooseBase(Card, _sanitizeImg)[_sanitizeImg](img).catch(console.error);\n\n      // The date is the only dealbreaker. We just skip a bad image link.\n      if (cleanDate) {\n        card = new Card({\n          isClue: isClue,\n          date: cleanDate,\n          info: cleanInfo,\n          img: cleanImg,\n          color: color\n        });\n        _classPrivateFieldLooseBase(card, _markSafe)[_markSafe]();\n        return card;\n      } else {\n        throw new Error(`Could not sanitize card input with date '${date}', info '${info}'`);\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    return card;\n  }\n\n  // PRIVATE METHODS\n  // Sanitize input \n\n  /**\n   * Return the year if positive or year BC if negative. (Deals with the year\n   * only.) \n   *\n   * Technically BC should be offset by one year but we told users to use\n   * negative numbers as years BC.\n   *\n   * Returns: Formatted string for year, with BC if the year was\n   * negative\n   */\n  dateToString() {\n    if (this.isClue) {\n      return \"Clue\";\n    } else {\n      let yearZero = new Date();\n      yearZero.setFullYear(0);\n      let displayYear = this.year;\n      if (this.date < yearZero) {\n        displayYear = `${-displayYear} bce`;\n      }\n      return displayYear;\n    }\n  }\n\n  // Return the date as YYYY year string.\n  get year() {\n    return this.date.getFullYear();\n  }\n  set year(YYYY) {\n    if (YYYY) {\n      this.date.setFullYear(YYYY);\n    }\n  }\n}\n_Card = Card;\nfunction _markSafe2() {\n  _classPrivateFieldLooseBase(this, _safe)[_safe] = true;\n  return this;\n}\nfunction _sanitizeDate2(raw) {\n  try {\n    let numTest = Number(raw);\n    if (!isNaN(numTest) && Number.isInteger(numTest) && numTest <= new Date().getFullYear()) {\n      let date = new Date();\n      date.setFullYear(numTest);\n      return date;\n    } else {\n      throw `Bad date input ${raw}`;\n      return null;\n    }\n  } catch (e) {\n    console.error(e);\n  }\n}\nfunction _sanitizeInfo2(raw) {\n  let node = document.createElement(\"span\");\n  node.textContent = raw;\n  return node.textContent;\n}\nasync function _sanitizeImg2(url) {\n  function getImageIfExists(url) {\n    return new Promise((resolve, reject) => {\n      const img = new Image();\n      img.src = url;\n      img.onload = () => resolve(true);\n      img.onerror = () => resolve(false);\n    });\n  }\n  if (!url) {\n    return null;\n  } else {\n    let imgTest = await getImageIfExists(url).catch(e => console.log(err));\n    if (imgTest === true) {\n      return url;\n    } else {\n      throw `Image not found at url '${url}'`;\n      return null;\n    }\n  }\n}\nObject.defineProperty(Card, _sanitizeImg, {\n  value: _sanitizeImg2\n});\nObject.defineProperty(Card, _sanitizeInfo, {\n  value: _sanitizeInfo2\n});\nObject.defineProperty(Card, _sanitizeDate, {\n  value: _sanitizeDate2\n});","map":{"version":3,"names":["Card","constructor","isClue","date","info","img","color","Object","defineProperty","_markSafe","value","_markSafe2","id","_safe","writable","crypto","randomUUID","Date","setFullYear","_classPrivateFieldLooseBase","isSafe","newSafeCard","card","cleanDate","_sanitizeDate","cleanInfo","_sanitizeInfo","cleanImg","_sanitizeImg","catch","console","error","Error","e","dateToString","yearZero","displayYear","year","getFullYear","YYYY","_Card","_sanitizeDate2","raw","numTest","Number","isNaN","isInteger","_sanitizeInfo2","node","document","createElement","textContent","_sanitizeImg2","url","getImageIfExists","Promise","resolve","reject","Image","src","onload","onerror","imgTest","log","err"],"sources":["/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/src/classes/Card.tsx"],"sourcesContent":["interface CardInput  {\n  isClue: boolean;  // Is this a clue (true) or answer?\n  date: number;     // Four-digit year of event\n  info: string;     // Brief description of event\n  img: string;      // Full URL of image\n  color: string     // CSS color to be used in timeline\n}\n\nexport default class Card {\n  isClue: boolean;\n  id: string;\n  date: Date;\n  info: string;\n  img: string;\n  color: string;\n  #safe: boolean;\n\n  // Each card gets the given info and a random unique identifier.\n  constructor({ isClue = true, date, info, img, color }: CardInput) {\n    this.isClue = isClue;\n    this.id = crypto.randomUUID();\n    this.date = new Date();\n    this.date.setFullYear(date);\n    this.info = info;\n    this.img = img;\n    this.color = color;\n    this.#safe = false; // Has this card been sanitized?\n  }\n\n  #markSafe(): Card {\n    this.#safe = true;\n    return this;\n  }\n\n  // PUBLIC METHODS\n\n  get isSafe(): boolean {\n    return this.#safe;\n  }\n\n  /** Creat a new card with sanitized input.\n   * - The date must be an integer string <= the current year (including\n   *   negative numbers).\n   * - The info is converted to plain text using textContent.\n   * - The image, if present, is downloaded and cached.\n   *\n   * The parameters are the same as for new Card().\n   *\n   * Returns: Card with validated content (with safe property set to true), or\n   * null if the input was invalid.\n   */\n  static async newSafeCard({ isClue, date, info, img, color }: \n                           CardInput): Card | null {\n    let card = null;\n    try {\n      let cleanDate = Card.#sanitizeDate(date);\n      let cleanInfo = Card.#sanitizeInfo(info);\n      let cleanImg = await Card.#sanitizeImg(img).catch(console.error);\n\n      // The date is the only dealbreaker. We just skip a bad image link.\n      if (cleanDate) {\n        card = new Card({\n          isClue: isClue, \n          date: cleanDate, \n          info: cleanInfo, \n          img: cleanImg, \n          color: color});\n          card.#markSafe();\n          return card;\n      } else {\n        throw new Error(`Could not sanitize card input with date '${date}', info '${info}'`);\n      }\n    } catch(e) {\n      console.error(e);\n    }\n    return card;\n  }\n\n  // PRIVATE METHODS\n  // Sanitize input \n  static #sanitizeDate(raw: any): Date {\n    try {\n      let numTest = Number(raw);\n      if (!isNaN(numTest) && \n          Number.isInteger(numTest) && \n            numTest <= new Date().getFullYear()) {\n\n          let date = new Date();\n          date.setFullYear(numTest);\n          return date;\n        } else {\n          throw `Bad date input ${raw}`;\n          return null;\n        }\n    } catch(e) { \n      console.error(e);\n    }\n  }\n\n  static #sanitizeInfo(raw) {\n    let node = document.createElement(\"span\");\n    node.textContent = raw;\n    return node.textContent;\n  }\n\n  static async #sanitizeImg(url) {\n    function getImageIfExists(url) { \n      return new Promise((resolve, reject) => {\n        const img = new Image();\n        img.src = url;\n        img.onload = () => resolve(true);\n        img.onerror = () => resolve(false);\n      });\n    }\n    if (!url) {\n      return null;\n    } else {\n      let imgTest = await getImageIfExists(url).catch(e => console.log(err));\n      if (imgTest === true) {\n        return url;\n      } else {\n        throw `Image not found at url '${url}'`;\n        return null;\n      }\n    } \n  }\n\n\n\n\n\n\n\n  /**\n   * Return the year if positive or year BC if negative. (Deals with the year\n   * only.) \n   *\n   * Technically BC should be offset by one year but we told users to use\n   * negative numbers as years BC.\n   *\n   * Returns: Formatted string for year, with BC if the year was\n   * negative\n   */\n  dateToString(): string { \n    if (this.isClue) {\n      return \"Clue\";\n    } else {\n      let yearZero = new Date();\n      yearZero.setFullYear(0);\n\n      let displayYear = this.year;\n      if (this.date < yearZero) {\n        displayYear = `${-displayYear} bce`; \n      } \n      return displayYear;\n    }\n  }\n\n  // Return the date as YYYY year string.\n  get year(): string { return this.date.getFullYear(); }\n\n  set year(YYYY: string): void { \n    if (YYYY) {\n      this.date.setFullYear(YYYY); \n    } \n  }\n\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}