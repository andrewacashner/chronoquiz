{"ast":null,"code":"var _jsxFileName = \"/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/src/components/Timeline.tsx\",\n  _s = $RefreshSig$();\nimport { useContext } from \"react\";\nimport TimelineContext from \"../store/TimelineContext\";\nimport Game from \"../classes/Game\";\nimport Card from \"./Card\";\n\n// Return a card element, if found at given coordinates; or null. \nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction cardAtCoord(x, y) {\n  let el = document.elementFromPoint(x, y);\n  return isCardElement(el) ? el : null;\n}\n\n// Get the center point between two coordinates.\nfunction midpoint(a,\n// smaller (left edge)\nb) {\n  return (b - a) / 2 + a;\n}\nfunction isCardElement(el) {\n  return el.className === \"card\";\n}\nexport default function Clues() {\n  _s();\n  let context = useContext(TimelineContext);\n  let [game, setGame] = [context.get, context.set];\n  let timeline = game.timeline;\n\n  // Allow to move by dragging. Insert gap to the left of a card when the drag\n  // point is in range to guess this card.\n  function dragoverHandler(event) {\n    event.preventDefault();\n    let bounds = event.target.getBoundingClientRect();\n    let center = midpoint(bounds.left, bounds.right);\n    if (event.clientX <= center) {\n      console.log(\"In range\");\n      let cardUnderDrag = cardAtCoord(event.clientX, event.clientY);\n      if (cardUnderDrag) {\n        let match = timeline.items.find(c => c.id === cardUnderDrag.id);\n        match.expand = true;\n        setGame(prevGame => new Game({\n          timeline: timeline,\n          ...prevGame\n        }));\n      }\n    }\n    event.dataTransfer.effectAllowed = \"move\";\n  }\n  function dragleaveHandler(event) {\n    let el = event.target;\n    if (isCardElement(el)) {\n      let match = timeline.items.find(c => c.id === el.id);\n      match.expand = false;\n      setGame(prevGame => new Game({\n        timeline: timeline,\n        ...prevGame\n      }));\n    }\n  }\n\n  /**\n   * When the user drops a card onto a timeline card, find the closest card,\n   * test if the date on the clue is between that card and its previous\n   * neighbor (if there is one); if so insert the card and increment the\n   * score; if not, do not insert the card and decrement the score.\n   */\n  function dropHandler(event) {\n    // Is the given clue between a given answer card and the one before it?\n    function isClueBetweenDates(clue,\n    // Dropped card\n    guess,\n    // Card that clue was dropped onto\n    preGuess) {\n      let clueDate = clue.dataset.when;\n      let guessDate = guess.dataset.when;\n      let isBeforeGuess = clueDate <= guessDate;\n      let noPreGuess = !preGuess;\n      let isAfterPreGuess = preGuess && clueDate >= preGuess.dataset.when;\n      let isAfterAnyPreGuess = noPreGuess || isAfterPreGuess;\n      return isBeforeGuess && isAfterAnyPreGuess;\n    }\n    event.preventDefault();\n\n    // Find nearest answer (first card found to right of click) to compare\n    let clue = game.clues.last();\n    let guessID = findFirstCardToRight(event);\n    let guessIndex = timeline.findIndex(c => c.id === guessID);\n    let guess = timeline[guessIndex];\n    if (guess) {\n      let beforeGuess = guess.previousElementSibling;\n      if (isClueBetweenDates(clue, guess, beforeGuess)) {\n        console.log(\"Correct: ++Score\");\n        setGame(prevGame => prevGame.copyWithNextClue().incrementScore());\n      } else {\n        console.log(\"Incorrect, --Score\");\n        flashAlert(clue);\n        setGame(prevGame => prevGame.decrementScore());\n      }\n    } else {\n      console.log(\"No card found at drop location\");\n    }\n  }\n  let dragDropInterface = {\n    onDrop: dropHandler,\n    onDragOver: dragoverHandler,\n    onDragLeave: dragleaveHandler\n  };\n  if (game.isActive && timeline && !(timeline !== null && timeline !== void 0 && timeline.isEmpty())) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"timeline\",\n      ...dragDropInterface,\n      children: timeline.items.map(card => /*#__PURE__*/_jsxDEV(Card, {\n        children: card\n      }, card.id, false, {\n        fileName: _jsxFileName,\n        lineNumber: 119,\n        columnNumber: 37\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 118,\n      columnNumber: 7\n    }, this);\n  }\n}\n_s(Clues, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n_c = Clues;\nvar _c;\n$RefreshReg$(_c, \"Clues\");","map":{"version":3,"names":["useContext","TimelineContext","Game","Card","jsxDEV","_jsxDEV","cardAtCoord","x","y","el","document","elementFromPoint","isCardElement","midpoint","a","b","className","Clues","_s","context","game","setGame","get","set","timeline","dragoverHandler","event","preventDefault","bounds","target","getBoundingClientRect","center","left","right","clientX","console","log","cardUnderDrag","clientY","match","items","find","c","id","expand","prevGame","dataTransfer","effectAllowed","dragleaveHandler","dropHandler","isClueBetweenDates","clue","guess","preGuess","clueDate","dataset","when","guessDate","isBeforeGuess","noPreGuess","isAfterPreGuess","isAfterAnyPreGuess","clues","last","guessID","findFirstCardToRight","guessIndex","findIndex","beforeGuess","previousElementSibling","copyWithNextClue","incrementScore","flashAlert","decrementScore","dragDropInterface","onDrop","onDragOver","onDragLeave","isActive","isEmpty","children","map","card","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/andrewacashner/Documents/computing/javascript/react/chronoquiz/src/components/Timeline.tsx"],"sourcesContent":["import { useContext } from \"react\";\nimport TimelineContext from \"../store/TimelineContext\";\n\nimport Game from \"../classes/Game\";\n\nimport Card from \"./Card\";\n\n// Return a card element, if found at given coordinates; or null. \nfunction cardAtCoord(x: number, y: number): HTMLElement {\n  let el = document.elementFromPoint(x, y);\n  return isCardElement(el) ? el : null;\n}\n\n// Get the center point between two coordinates.\nfunction midpoint(\n  a: number, // smaller (left edge)\n  b: number  // larger (right edge)\n): number {\n  return (b - a) / 2 + a;\n}\n \nfunction isCardElement(el: HTMLElement): boolean {\n  return el.className === \"card\";\n}\n\n\nexport default function Clues() {\n  let context = useContext(TimelineContext);\n  let [game, setGame] = [context.get, context.set];\n  let timeline = game.timeline;\n\n  // Allow to move by dragging. Insert gap to the left of a card when the drag\n  // point is in range to guess this card.\n  function dragoverHandler(event: React.DragEvent<HTMLElement>): void {\n    event.preventDefault();\n  \n    let bounds = event.target.getBoundingClientRect();\n    let center = midpoint(bounds.left, bounds.right);\n  \n    if (event.clientX <= center) {\n      console.log(\"In range\");\n      let cardUnderDrag = cardAtCoord(event.clientX, event.clientY);\n      if (cardUnderDrag) {\n        let match = timeline.items.find(c => c.id === cardUnderDrag.id);\n        match.expand = true;\n        setGame(prevGame => new Game({ timeline: timeline, ...prevGame }));\n      }\n    }\n    event.dataTransfer.effectAllowed = \"move\";\n  }\n  \n  function dragleaveHandler(event: React.DragEvent<HTMLElement>): void {\n    let el = event.target;\n    if (isCardElement(el)) {\n      let match = timeline.items.find(c => c.id === el.id);\n      match.expand = false;\n      setGame(prevGame => new Game({ timeline: timeline, ...prevGame }));\n    }\n  }\n\n  /**\n   * When the user drops a card onto a timeline card, find the closest card,\n   * test if the date on the clue is between that card and its previous\n   * neighbor (if there is one); if so insert the card and increment the\n   * score; if not, do not insert the card and decrement the score.\n   */\n  function dropHandler(event: React.DropEvent<HTMLElement>): void {\n    \n    // Is the given clue between a given answer card and the one before it?\n    function isClueBetweenDates(\n      clue: HTMLElement,            // Dropped card\n      guess: HTMLElement,           // Card that clue was dropped onto\n      preGuess: HTMLElement | null  // previousSibling of guess, if exists\n    ): boolean {\n      let clueDate = clue.dataset.when;\n      let guessDate = guess.dataset.when;\n      let isBeforeGuess = clueDate <= guessDate;\n    \n      let noPreGuess = !preGuess;\n      let isAfterPreGuess = preGuess && (clueDate >= preGuess.dataset.when);\n      let isAfterAnyPreGuess = noPreGuess || isAfterPreGuess;\n    \n      return isBeforeGuess && isAfterAnyPreGuess;\n    }\n\n    event.preventDefault();\n\n    // Find nearest answer (first card found to right of click) to compare\n    let clue = game.clues.last();\n    let guessID = findFirstCardToRight(event);\n    let guessIndex = timeline.findIndex(c => c.id === guessID);\n    let guess = timeline[guessIndex];\n\n    if (guess) {\n      let beforeGuess = guess.previousElementSibling;\n\n      if (isClueBetweenDates(clue, guess, beforeGuess)) {\n        console.log(\"Correct: ++Score\");\n        setGame(prevGame => prevGame.copyWithNextClue().incrementScore());\n      } else {\n        console.log(\"Incorrect, --Score\");\n        flashAlert(clue);\n        setGame(prevGame => prevGame.decrementScore());\n      }\n    } else {\n      console.log(\"No card found at drop location\");\n    }\n  }\n\n  let dragDropInterface = {\n    onDrop: dropHandler,\n    onDragOver: dragoverHandler,\n    onDragLeave: dragleaveHandler\n  } \n\n  if (game.isActive && timeline && !timeline?.isEmpty()) {\n    return(\n      <div className=\"timeline\" {...dragDropInterface}>\n        {timeline.items.map(card => <Card key={card.id}>{card}</Card>)}\n      </div>\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}